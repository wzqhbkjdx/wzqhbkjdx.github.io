<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="风车老家">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="风车老家">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="风车老家">
<meta name="twitter:description">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"always"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> 风车老家 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">风车老家</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/27/mysqlinnodb/" itemprop="url">
                  MySQL技术内幕 InnoDB存储引擎 读书笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-27T19:05:51+08:00" content="2016-06-27">
              2016-06-27
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/数据库/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="MySQL技术内幕"><a href="#MySQL技术内幕" class="headerlink" title="MySQL技术内幕"></a>MySQL技术内幕</h1><h2 id="MySQL体系结构和存储引擎"><a href="#MySQL体系结构和存储引擎" class="headerlink" title="MySQL体系结构和存储引擎"></a>MySQL体系结构和存储引擎</h2><h3 id="数据库和数据库实例"><a href="#数据库和数据库实例" class="headerlink" title="数据库和数据库实例"></a>数据库和数据库实例</h3><p>数据库：文件的集合，是依照某种数据模型组织起来并存放于二级存储器中的数据集合</p>
<p>数据库实例：进程/线程，是应用程序，是位于用户和操作系统之间的一层数据库管理软件</p>
<p>在MySQL中，数据库和数据库实例通常是一一对应关系，在集群情况下有可能存在单一数据库被多个实例访问的情况</p>
<p>MySQL是单进程多线程的数据结构</p>
<p>启动数据库查看数据库进程</p>
<p>bym$ mysql.server start<br>Starting MySQL<br>SUCCESS!<br>bym$ ps -ef | grep mysqld<br>501  1000     1   0  3:56下午 ttys000    0:00.02 /bin/sh /usr/local/Cellar/mysql/5.7.11/bin/    mysqld_safe –datadir=/usr/local/var/mysql –pid-file=/usr/local/var/mysql/BYMdeMac-mini.local.pid<br>501  1092  1000   0  3:56下午 ttys000    0:00.35 /usr/local/Cellar/mysql/5.7.11/bin/mysqld –basedir=/usr/local/Cellar/mysql/5.7.11 –datadir=/usr/local/var/mysql –plugin-dir=/usr/local/Cellar/mysql/5.7.11/lib/plugin –log-error=/usr/local/var/mysql/BYMdeMac-mini.local.err –pid-file=/usr/local/var/mysql/BYMdeMac-mini.local.pid<br>501  1094   992   0  3:56下午 ttys000    0:00.00 grep mysqld</p>
<p>cd到MySQL的bin文件夹执行下边的命令查询MySQL，启动时读取的配置文件，Linux环境下，MySQL的配置文件在<code>/etc/my.cnf</code></p>
<p>BYMdeMac-mini:bin bym$ ./mysql –help | grep my.cnf<br>order of preference, my.cnf, $MYSQL_TCP_PORT,/etc/my.cnf /etc/mysql/my.cnf /usr/local/etc/my.cnf ~/.my.cnf</p>
<h3 id="MySQL体系结构如图："><a href="#MySQL体系结构如图：" class="headerlink" title="MySQL体系结构如图："></a>MySQL体系结构如图：</h3><p><img src="/images/mysql.png" alt="MySQLStructure"></p>
<p>MySQL的最大特点是插件式存储引擎</p>
<p>新建表 更换存储引擎</p>
<p>mysql&gt; create table mytest engine=myisam as select * from providers;<br>Query OK, 93 rows affected (0.01 sec)<br>Records: 93  Duplicates: 0  Warnings: 0</p>
<p>mysql&gt; alter table mytest engine=innodb;<br>Query OK, 93 rows affected (0.02 sec)<br>Records: 93  Duplicates: 0  Warnings: 0</p>
<p>连接MySQL</p>
<ul>
<li>TCP/IP套接字</li>
<li>命名管道、共享内存（两个需要通信的进程在同一个服务器上）</li>
<li>Unix套接字</li>
</ul>
<h2 id="InnoDB存储引擎概述"><a href="#InnoDB存储引擎概述" class="headerlink" title="InnoDB存储引擎概述"></a>InnoDB存储引擎概述</h2><p>事务安全</p>
<p>第一个完整支持ACID事务的MySQL存储引擎。一致性非锁定读，支持外键。</p>
<p><strong>InnoDB架构</strong></p>
<p>InnoDB有多个内存块构成存储引擎内存池，还有多个后台线程。</p>
<p>内存池：维护所有进程/线程需要访问的多个内部数据结构，缓存磁盘上的数据方便快速读取，并在对磁盘文件上的数据进行修改之前在这里缓存，重做日志缓冲。<br>包括：缓冲池，重做日志缓冲池，额外的内存池</p>
<p>//缓冲池，占最大块内存，将数据库文件按页（16KB）读取到缓冲池，按照最近最少使用算法（LRU）来保留在缓冲池的缓存数据。数据文件修改，首先修改缓冲池中的页，然后再按照一定的频率将修改后的脏页flush到文件中。<br>show engine innodb status;<br>数据页<br>索引页<br>插入缓冲<br>自适应哈希索引<br>锁信息<br>数据字典信息</p>
<p>后台线程：刷新内存池中的数据，确保缓存的是最近的数据，将已修改的数据文件刷新到磁盘文件，同时保证在数据库异常的情况下InnoDB能恢复到正常运行状态。<br>包括：IOThread masterThread 锁监控线程 错误监控线程</p>
<p>InnoDB的主要工作是在masterThread中完成的。masterThread的优先级最高，masterThread中包含如下循环：<br>loop 主循环：每秒一次和10秒一次操作<br>每秒一次：<br>日志缓冲刷新到磁盘（总是）<br>合并插入缓冲（可能）<br>最多刷新100个InnoDB的缓冲池脏页到磁盘（可能）<br>如果当前没有用户活动，切换到background loop（可能）<br>每10秒一次：<br>刷新100个InnoDB的缓冲池脏页到磁盘（可能）<br>合并最多5个插入缓冲（总是）<br>日志缓冲刷新到磁盘（总是）<br>删除无用Undo页（总是）<br>刷新100个或者10个脏页到磁盘（总是）<br>产生一个检查点（总是）</p>
<p>background loop 后台循环<br>删除无用的Undo页（总是）<br>合并20个插入缓冲（总是）<br>调回到主循环（总是）<br>不断刷新100个页，直到符合条件(有可能在flush loop中实现)<br>flush loop 刷新循环<br>suspend loop 暂停循环</p>
<p>InnoDB Plugin提供了参数innodb_io_capacity，表示磁盘IO的吞吐量，InnoDB Plugin会根据该吞吐量，按照一定的百分比来刷新相对数量的页。</p>
<p>innodb_max_dirty_pages_pct，默认值为90%，如果内存很大或者数据库压力很大，刷新脏页的速度会降低。InnoDB Plugin 将该值改为75%，加快脏页的刷新频率，保证磁盘IO的负载。</p>
<p>innodb_adaptive_flushing 自适应刷新，该参数的引入使得InnoDB通过一个名为buf_flush_get_desired_flush_rate的函数来判断需要刷新的脏页最合适的数量。使得当脏页比例小于innodb_max_dirty_pages_pct时也会刷新。提高了性能。</p>
<p><strong>关键特性</strong></p>
<ul>
<li>插入缓存</li>
</ul>
<p>应对非聚集索引插入的离散型导致的性能下降，InnoDB存储引擎开创性的设计了插入缓冲。对于非聚集索引的插入或者更新操作，不是每次直接插入到索引页，而是先判断插入的非聚集索引是否在缓冲池中，如果在，则直接插入，如果不在，则先放入一个插入缓冲区，然后再以一定的频率执行插入缓冲和非聚集索引页子节点的合并操作，这时通常能够将多个插入合并到一个操作中，提高了对非聚集索引执行插入和修改操作的性能。</p>
<ul>
<li>doublewrite</li>
<li>自适应哈希索引</li>
</ul>
<h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><ul>
<li>参数文件：数据库文件所在位置，初始化参数。</li>
<li>日志文件</li>
<li>socket文件</li>
<li>pid文件</li>
<li>MySQL表结构文件</li>
<li>存储引擎文件</li>
</ul>
<h2 id="表"><a href="#表" class="headerlink" title="表"></a>表</h2><p>表是关于特定实体的数据集合，是关系型数据库模型的核心。</p>
<p>所有数据都被逻辑地存放在一个空间中，即表空间（tablesspace），表空间由段（segment），区（extent），页（page）组成。</p>
<p>段：数据段 索引段，回滚段，InnoDB的引擎表是索引组织的，因此数据即索引，索引即数据。数据段即B+树的叶节点，索引段即B+树的非叶点。</p>
<p>区：64个连续的页，每个页16KB，每个区1MB，大的数据段，InnoDB最多每次可以申请4个区，以此来保证数据的顺序性能。</p>
<p>页：是InnoDB磁盘管理的最小单位。</p>
<p>数据页 B-tree Node<br>Undo页<br>系统页<br>事务数据页<br>插入缓冲区位图页<br>插入缓冲区空闲列表页<br>未压缩的二进制大对象页<br>压缩的二进制大对象页</p>
<p>行：</p>
<h2 id="数据库索引算法"><a href="#数据库索引算法" class="headerlink" title="数据库索引算法"></a>数据库索引算法</h2><p>二分查找<br>B+树存储  聚集索引 辅助索引</p>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>锁机制是数据库系统区别于文件系统的一个关键特性，用于管理对共享资源的并发访问。</p>
<p>InnoDB存储引擎提供一致性的非锁定读，行级锁支持，行级锁没有相关的开销，可以同时得到并发性和一致性。</p>
<p><strong>锁的类型</strong></p>
<ul>
<li>共享锁 允许事务读取一行数据；</li>
<li>排他锁 允许事务更新或删除一条数据。</li>
</ul>
<p>一致性非锁定读，读取快照。</p>
<h2 id="事务（Transaction）"><a href="#事务（Transaction）" class="headerlink" title="事务（Transaction）"></a>事务（Transaction）</h2><p>事务会把数据库从一种一致状态转换为另一种一致状态。</p>
<p>ACID特性：</p>
<p>原子性 automicity</p>
<p>一致性 consistency</p>
<p>隔离性 isolation（锁）</p>
<p>持久性 durability</p>
<p>原子性、一致性、持久性通过数据库的redo和undo来完成。</p>
<p>事务日志：redo日志文件和InnoDB存储引擎日志缓冲。在写数据前先写日志，即对于内存缓冲池中页的修改，先是写入重做日志文件，然后再写入磁盘。</p>
<p>undo日志：记录了事务的行为，存放在数据库内部的一个特殊段中，成为undo段，位于共享表空间内。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/13/view/" itemprop="url">
                  View 的工作原理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-13T17:16:58+08:00" content="2016-06-13">
              2016-06-13
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/源码分析/" itemprop="url" rel="index">
                    <span itemprop="name">源码分析</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="ViewRoot-amp-DocerView"><a href="#ViewRoot-amp-DocerView" class="headerlink" title="ViewRoot &amp; DocerView"></a>ViewRoot &amp; DocerView</h3><p>ViewRoot对应于 ViewRootImpl类，是连接WindowManager和DecorView的纽带，View的三大流程（measure layout draw）都是通过ViewRoot来完成的，在ActivityThread中，当Activit被创建完毕后，会将DecorView添加到Window中，创建ViewRootImpl,并将ViewRootImpl对象和DecorView建立联系</p>
<p>View的绘制是从ViewRoot的performTraversals方法开始的，进过measure layout draw，将View绘制出来。</p>
<p>measure 确定View的宽和高</p>
<p>layout 确定在父容器中的位置</p>
<p>draw负责将View绘制在屏幕上</p>
<p>performMeasure——&gt;measure——&gt;onMeasure(在该方法中完成对所有子元素的measure过程) getMeasureWidth getMeasureHeight</p>
<p>performLayout 同理 getTop getBottom getLeft getRight</p>
<p>performDraw</p>
<h3 id="MeasureSpec"><a href="#MeasureSpec" class="headerlink" title="MeasureSpec"></a>MeasureSpec</h3><p>View的测量规格</p>
<p>MeasureSpec在很大程度上决定了View的尺寸规格，在测量的过程中，系统会将View的LayoutParam根据父容器所施加的规则转换成对应的MeasureSpec,然后再根据这个MeasureSpec来测量View的宽和高</p>
<p>MeasureSpec 代表32位int值，高2位代表SpecMode 低30位代表SpecSize，</p>
<p>SpecMode </p>
<p>UNSPECIFIED 系统内部使用</p>
<p>EXACTLY match_parent 有具体宽和高的</p>
<p>AT_MOST wrap_content</p>
<p>DecorView：的MeasureSpec尺寸由窗口的尺寸和其自身的LayoutParams来共同决定</p>
<p>普通View：    的MeasureSpec，由父容器的MeasureSpec和其自身的LayoutParams共同确定</p>
<h3 id="View的工作流程"><a href="#View的工作流程" class="headerlink" title="View的工作流程"></a>View的工作流程</h3><p>measure</p>
<pre><code>protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    setMeasuredDimension(
    getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),
    getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec)
    );
}

public static int getDefaultSize(int size, int measureSpec) {
    int result = size;
    int specMode = MeasureSpec.getMode(measureSpec);
    int specSize = MeasureSpec.getSize(measureSpec);

    switch (specMode) {
    case MeasureSpec.UNSPECIFIED:
        result = size;
        break;
    case MeasureSpec.AT_MOST:
    case MeasureSpec.EXACTLY:
        result = specSize;
        break;
    }
    return result;
}
</code></pre><p>得出结论：直接继承View的自定义控件，需要重写onMeasure方法，如果该控件的宽或者高有wrap_content属性时，需要我们手动设定大小，否则就相当于match_parent</p>
<p>ViewGroup的measure过程：除了完成自身的measure过程，还会去遍历调用其各个子元素的measure方法，各个子元素再递归去执行这个过程。</p>
<p>ViewGroup是抽象类，没有onMeasure方法，提供了measureChildren方法：</p>
<pre><code>protected void measureChildren(int widthMeasureSpec, int heightMeasureSpec) {
    final int size = mChildrenCount;
    final View[] children = mChildren;
    for (int i = 0; i &lt; size; ++i) {
        final View child = children[i];
        if ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) {
            measureChild(child, widthMeasureSpec, heightMeasureSpec);
        }
    }
}
</code></pre><p>layout</p>
<p>draw</p>
<p>LinearLayout 的measure过程</p>
<pre><code>protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    if (mOrientation == VERTICAL) {
        measureVertical(widthMeasureSpec, heightMeasureSpec);
    } else {
        measureHorizontal(widthMeasureSpec, heightMeasureSpec);
    }
}
</code></pre><p>在Activity中获取View的宽和高</p>
<p>由于Activity的生命周期方法和View的measure过程不同步，通过getMeasureWidth/Heigth在onCreate onStrart onResume中均无法正确获得View 的宽高信息。解决该问题的方法：</p>
<ul>
<li>复写Activity的onWindowFocusChanged方法</li>
</ul>
<p>onWindowFocusChanged在窗口得到或者失去焦点的时候都会调用，如果频繁的进行onResume和onPause，那么onWindowFocusChanged会被频繁的调用。</p>
<pre><code>@Override
public void onWindowFocusChanged(boolean hasFocus) {
    super.onWindowFocusChanged(hasFocus);
    if(hasFocus) {
        int hight = iv_picture.getMeasuredHeight();
        int width = iv_picture.getMeasuredWidth();
    }
}
</code></pre><ul>
<li>view.post(runnable)</li>
</ul>
<p>通过post将runnable投递到消息队列的尾部，然后等待Looper调用此runnable的时候，View已经初始化好了。</p>
<pre><code>@Override
protected void onStart() {
    super.onStart();
    iv_picture.post(new Runnable() {
        @Override
        public void run() {
            int hight = iv_picture.getMeasuredHeight();
            int width = iv_picture.getMeasuredWidth();
        }
    });
}
</code></pre><ul>
<li>使用ViewTreeObserver</li>
</ul>
<p>当View树的状态发生改变或者View树内部的View可见性发生改变时，onGLoalLayout方法将会被回调。</p>
<pre><code>@Override
protected void onStart() {
    super.onStart();

    ViewTreeObserver observer = iv_picture.getViewTreeObserver();
    observer.addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {
        @Override
        public void onGlobalLayout() {
            iv_picture.getViewTreeObserver().removeOnGlobalLayoutListener(this);
            int hight = iv_picture.getMeasuredHeight();
            int width = iv_picture.getMeasuredWidth();
        }
    });

}
</code></pre><h2 id="Layout过程"><a href="#Layout过程" class="headerlink" title="Layout过程"></a>Layout过程</h2><p>ViewGroup用来确定子元素的位置，当ViewGroup的位置确定后，在它的onLayout方法中，会遍历所有子元素并调用其的layout方法，在子元素的layout方法中，onLayout又会被调用。</p>
<pre><code>public void layout(int l, int t, int r, int b) {
    if ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != 0) {
        onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec);
        mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;
    }

    int oldL = mLeft;
    int oldT = mTop;
    int oldB = mBottom;
    int oldR = mRight;

    boolean changed = isLayoutModeOptical(mParent) ?
            setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);

    if (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) {
        onLayout(changed, l, t, r, b);
        mPrivateFlags &amp;= ~PFLAG_LAYOUT_REQUIRED;

        ListenerInfo li = mListenerInfo;
        if (li != null &amp;&amp; li.mOnLayoutChangeListeners != null) {
            ArrayList&lt;OnLayoutChangeListener&gt; listenersCopy =
                    (ArrayList&lt;OnLayoutChangeListener&gt;)li.mOnLayoutChangeListeners.clone();
            int numListeners = listenersCopy.size();
            for (int i = 0; i &lt; numListeners; ++i) {
                listenersCopy.get(i).onLayoutChange(this, l, t, r, b, oldL, oldT, oldR, oldB);
            }
        }
    }

    mPrivateFlags &amp;= ~PFLAG_FORCE_LAYOUT;
    mPrivateFlags3 |= PFLAG3_IS_LAID_OUT;
}
</code></pre><p>layout的过程概述：首先通过setFrame方法来设定View的四个顶点的位置，接着调用onLayout方法，用于父容器确定子元素的位置。</p>
<p>LinearLayout的onLayout方法：</p>
<pre><code>@Override
protected void onLayout(boolean changed, int l, int t, int r, int b) {
    if (mOrientation == VERTICAL) {
        layoutVertical(l, t, r, b);
    } else {
        layoutHorizontal(l, t, r, b);
    }
}

void layoutVertical(int left, int top, int right, int bottom) {
    final int paddingLeft = mPaddingLeft;

    int childTop;
    int childLeft;

    // Where right end of child should go
    final int width = right - left;
    int childRight = width - mPaddingRight;

    // Space available for child
    int childSpace = width - paddingLeft - mPaddingRight;

    final int count = getVirtualChildCount();

    final int majorGravity = mGravity &amp; Gravity.VERTICAL_GRAVITY_MASK;
    final int minorGravity = mGravity &amp; Gravity.RELATIVE_HORIZONTAL_GRAVITY_MASK;

    switch (majorGravity) {
       case Gravity.BOTTOM:
           // mTotalLength contains the padding already
           childTop = mPaddingTop + bottom - top - mTotalLength;
           break;

           // mTotalLength contains the padding already
       case Gravity.CENTER_VERTICAL:
           childTop = mPaddingTop + (bottom - top - mTotalLength) / 2;
           break;

       case Gravity.TOP:
       default:
           childTop = mPaddingTop;
           break;
    }

    for (int i = 0; i &lt; count; i++) {
        final View child = getVirtualChildAt(i);
        if (child == null) {
            childTop += measureNullChild(i);
        } else if (child.getVisibility() != GONE) {
            final int childWidth = child.getMeasuredWidth();
            final int childHeight = child.getMeasuredHeight();

            final LinearLayout.LayoutParams lp =
                    (LinearLayout.LayoutParams) child.getLayoutParams();

            int gravity = lp.gravity;
            if (gravity &lt; 0) {
                gravity = minorGravity;
            }
            final int layoutDirection = getLayoutDirection();
            final int absoluteGravity = Gravity.getAbsoluteGravity(gravity, layoutDirection);
            switch (absoluteGravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) {
                case Gravity.CENTER_HORIZONTAL:
                    childLeft = paddingLeft + ((childSpace - childWidth) / 2)
                            + lp.leftMargin - lp.rightMargin;
                    break;

                case Gravity.RIGHT:
                    childLeft = childRight - childWidth - lp.rightMargin;
                    break;

                case Gravity.LEFT:
                default:
                    childLeft = paddingLeft + lp.leftMargin;
                    break;
            }

            if (hasDividerBeforeChildAt(i)) {
                childTop += mDividerHeight;
            }

            childTop += lp.topMargin;
            setChildFrame(child, childLeft, childTop + getLocationOffset(child),
                    childWidth, childHeight);
            childTop += childHeight + lp.bottomMargin + getNextLocationOffset(child);

            i += getChildrenSkipCount(child, i);
        }
    }
}
</code></pre><p>在上面的代码中，可以看到，layoutVertial方法会遍历所有子元素，并调用setChildFrame方法来为子元素指定对应的位置，其中childTop会逐渐增大，说明后面的子元素会被放在考下的位置。setChildFrame方法调用了子元素的layout方法。</p>
<p>那么：getMeasureWidth 和getMeasuerWidth的区别<br>一般情况下测量宽高和最终宽高是相等的，只是测量宽高形成与View的measure过程，最终宽高形成于View的layout过程。</p>
<h2 id="Draw过程"><a href="#Draw过程" class="headerlink" title="Draw过程"></a>Draw过程</h2><ul>
<li>background.draw(cavas) 绘制背景</li>
<li>onDraw 绘制自己</li>
<li>dispatchDraw 绘制children</li>
<li>onDrawScrollBars 绘制装饰</li>
</ul>
<p>以上全文是学习 <a href="http://item.jd.com/11760209.html" target="_blank" rel="external">《Android开发艺术探索》</a> 后的笔记</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/24/priorityqueue/" itemprop="url">
                  优先队列
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-24T16:16:43+08:00" content="2016-05-24">
              2016-05-24
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/数据结构与算法/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构与算法</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="数据结构与算法——优先队列-priority-queue"><a href="#数据结构与算法——优先队列-priority-queue" class="headerlink" title="数据结构与算法——优先队列(priority queue)"></a>数据结构与算法——优先队列(priority queue)</h3><p><img src="http://img1.imgtn.bdimg.com/it/u=2643490497,3065329328&amp;fm=21&amp;gp=0.jpg" alt="priority queue"></p>
<blockquote>
<p>优先队列的两种基本操作</p>
</blockquote>
<ul>
<li>insert(enqueue)</li>
<li>deleteMin(dequeue)</li>
</ul>
<blockquote>
<p>优先队列的实现——二叉堆(binary heap)</p>
</blockquote>
<ul>
<li>结构性</li>
<li>堆序性(heap-order property)：目的是快速找到最小的元素，所以讲最小元素放在根上，且所有的子树也都是堆结构，所以所有的节点都小于它的子节点。所以findMin的操作是常数时间</li>
</ul>
<p>完全二叉树： 除了底层都被完全填充的二叉树(底层从左到右依次填充，所以有可能没有完全填充)</p>
<p>一颗高为h的完全二叉树，有2^h到2^(h+1)个节点，即完全二叉树的高为O(logN)</p>
<p>完全二叉树用数组存储的规律：对于数组中任意位置i上的元素，它的左儿子位于2i处，右儿子位于(2i+1)处，父节点位于i/2(向下取整)处。遍历简单，运行快速。</p>
<p>优先队列完成insert和deleteMin两种操作的关键在于“上滤”和 “下滤”两种方法的实现</p>
<p>insert后，实现上滤操作</p>
<pre><code>public void insert(AnyType x) {

    //在插入之前先判断是否还有空间
    if(currentSize == array.length - 1) {

        enlargeArray(array.length * 2 + 1);

    }

    //上滤操作
    int hole = ++ currentSize;
    for(; hole &gt; 1 &amp;&amp; x.compareTo(array[hole/2]) &lt; 0 ; hole /=2) {
        array[hole] = array[hole / 2]; //没有使用swap(x,y)这种方式，这样交换的次数比较少
    }
    array[hole] = x;

}
</code></pre><p>deleteMin后实现下滤操作</p>
<pre><code>public AnyType deleteMin() {

    if(isEmpty()) {
//            throw new Exception();
    }

    AnyType minItem = findMin();
    array[1] = array[currentSize];
    currentSize--;
    percolateDown(1);

    return minItem;

}

private void percolateDown(int hole) {

    int child;
    //缓存要下虑的值
    AnyType tmp = array[hole];

    /**
     * 1. 找到hole的两个子节点中较小的一个child
     * 2. 比较child的值和tmp中的值大小
     * 3. child大于tmp：结束循环，tmp直接保存在hole中
     * 4. child小于tmp：将child的值保存到hole中，下一个hole = child
     * 5. 进行下一轮循环
     */

    for(; hole * 2 &lt; currentSize; hole = child) {

        //找到hole的左子节点
        child = hole * 2;
        //右子节点 &lt; 左子节点
        if(child &lt; currentSize &amp;&amp; array[child + 1].compareTo(array[child]) &lt; 0) {
            child ++;
        }

        //child 和 tmp比较大小
        if(array[child].compareTo(tmp) &lt; 0) {
            array[hole] = array[child];
        } else {
            break;
        }

    }

    array[hole] = tmp;

}
</code></pre><p><img src="http://www.zgxue.com/bloguploapic/20141116001225568.jpg" alt="priority queue"></p>
<p>堆结构的实现：</p>
<p>public class BinaryHeap<anytype extends="" comparable<?="" super="" anytype="">&gt; {</anytype></p>
<pre><code>private static final int DEFAULT_CAPACITY = 10;
private int currentSize;
private AnyType[] array;

public BinaryHeap() {
    this(DEFAULT_CAPACITY);
}

public BinaryHeap(int capacity) {
    currentSize = 0;
    array = (AnyType[]) new Comparable[capacity + 1];
}

public BinaryHeap(AnyType[] items) {

    currentSize = items.length;
    array = (AnyType[]) new Comparable[(currentSize + 2) * 11 / 10];

    int i = 1;
    for(AnyType item : items) {
        array[i++] = item;
    }

    buildHeap(); //建堆
}

/**
 * 建堆的过程：从完全二叉树的倒数第二层子树开始，对每个有子节点的节点执行下滤操作，
 * 确保每个节点小于自己的两个子节点即可
 */
private void buildHeap() {

    for(int i = currentSize / 2; i &gt; 0; i++) {
        percolateDown(i);
    }


}


public AnyType findMin() {

    if(isEmpty()) {
        return null;
    } else {
        return array[1];
    }

}

private boolean isEmpty() {

    return currentSize == 0;
}

private void enlargeArray(int size) {

    if(size &lt;= array.length) {
        return;
    } else {

        AnyType[] oldArray = array;
        array = (AnyType[]) new Comparable[size + 1];

        int i = 0;
        for(AnyType item : oldArray) {
            array[i++] = item;
        }
    }

}

/**
 * 插入时长：O(logN)
 * @param x
 */
public void insert(AnyType x) {

    //在插入之前先判断是否还有空间
    if(currentSize == array.length - 1) {

        enlargeArray(array.length * 2 + 1);

    }

    //上滤操作
    int hole = ++ currentSize;
    for(; hole &gt; 1 &amp;&amp; x.compareTo(array[hole/2]) &lt; 0 ; hole /=2) {
        array[hole] = array[hole / 2]; //没有使用swap(x,y)这种方式，这样交换的次数比较少
    }
    array[hole] = x;

}

public AnyType deleteMin() {

    if(isEmpty()) {
//            throw new Exception();
    }

    AnyType minItem = findMin();
    array[1] = array[currentSize];
    currentSize--;
    percolateDown(1);

    return minItem;


}

private void percolateDown(int hole) {

    int child;
    //缓存要下虑的值
    AnyType tmp = array[hole];

    /**
     * 1. 找到hole的两个子节点中较小的一个child
     * 2. 比较child的值和tmp中的值大小
     * 3. child大于tmp：结束循环，tmp直接保存在hole中
     * 4. child小于tmp：将child的值保存到hole中，下一个hole = child
     * 5. 进行下一轮循环
     */

    for(; hole * 2 &lt; currentSize; hole = child) {

        //找到hole的左子节点
        child = hole * 2;
        //右子节点 &lt; 左子节点
        if(child &lt; currentSize &amp;&amp; array[child + 1].compareTo(array[child]) &lt; 0) {
            child ++;
        }

        //child 和 tmp比较大小
        if(array[child].compareTo(tmp) &lt; 0) {
            array[hole] = array[child];
        } else {
            break;
        }


    }

    array[hole] = tmp;



}

}
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/24/vim/" itemprop="url">
                  vim基本操作
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-24T13:43:13+08:00" content="2016-05-24">
              2016-05-24
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/教程/" itemprop="url" rel="index">
                    <span itemprop="name">教程</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li>在某行按 A 添加文本，光标定位在该行的哪个字符不重要 a 在光标后插入文本</li>
<li>d w 从光标定位的字符删除到下一个单词的起始处 所以w键可以定位到下一个单词的起始处</li>
<li>d e 从光标定位的字符删除到该单词的末尾 e定位到本单词的末尾</li>
<li>d $ 从当前光标删除到行末 $定位到行尾</li>
<li>2 w 向后移动两个单词到单词的起始位置</li>
<li>3 e 向后移动三个单词，到单词的末尾</li>
<li>0 移动光标当行首</li>
<li>dd 删除当前行 xdd （x代表数字）删除x行</li>
<li>u撤销前一操作，U撤销整行的操作，Ctrl + r 恢复被撤销的操作</li>
<li>dd可以剪切 p粘贴</li>
<li>r 替换当前光标所在位置的字符</li>
<li>ce cw 改变一个单词并进入插入模式</li>
<li>Ctrl + g 显示当前行信息</li>
<li>G跳转到当前编辑文本的最后一行 gg跳转到当前文本的首行</li>
<li>行号 + G 跳转到该行</li>
<li>/ + 要搜索的内容 向后搜索</li>
<li>？ + 要搜索的内容 向前搜索</li>
<li>Ctrl + o 让光标回到之前的位置</li>
<li>Ctrl + i 与 Ctrl + o 相反</li>
<li>% 找到配对的{ [ (</li>
<li>:s/old/new/g 将光标当前行的第一个old字符串替换为new字符串</li>
<li>:%s/old/new/g  替换整个文本    :%s/old/new/gc  替换整个文本并对每一个替换进行提示</li>
<li>: + ! + 命令 + &lt;回车&gt; 在vim内执行shell命令 如: +  ! + ls</li>
<li>v 进入可视模式进行选取 选取好文本后，输入：可以看到vim底部出现：’&lt;,’&gt; 输入w TEST 可以将选取好的文件保存的TEST中</li>
<li>：r TEST 将TEST文件写入到当前文件中 : r ls 将ls命令显示的文件写入到当前文件中</li>
<li>o 在当前行下面插入一行 O 在当前行上方插入一行</li>
<li>R 连续替换多个字符</li>
<li>y 和 v结合进行复制 yw复制一个字符</li>
<li>:set ic 查找时忽略大小写 :set noic禁用大小写 只在一次查找中忽略大小写 /test\c test为要查找的单词</li>
<li>:set is 查找短语时显示部分匹配</li>
<li>:set hls 高亮显示</li>
<li>使用Ctrl + d 以及tab的自动补全功能</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/22/retrofit/" itemprop="url">
                  retrofit
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-22T14:43:19+08:00" content="2016-05-22">
              2016-05-22
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/源码分析/" itemprop="url" rel="index">
                    <span itemprop="name">源码分析</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="/images/retrofit2.png" alt="retrofit2"></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/22/JVM/" itemprop="url">
                  Java虚拟机概述（一）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-22T14:30:37+08:00" content="2016-05-22">
              2016-05-22
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Java虚拟机/" itemprop="url" rel="index">
                    <span itemprop="name">Java虚拟机</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="/images/JVM.png" alt="JVM"></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/21/handler/" itemprop="url">
                  Handler、Looper
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-21T17:46:00+08:00" content="2016-05-21">
              2016-05-21
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/源码分析/" itemprop="url" rel="index">
                    <span itemprop="name">源码分析</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Handler、Looper"><a href="#Handler、Looper" class="headerlink" title="Handler、Looper"></a>Handler、Looper</h3><p>学习了<a href="http://www.cnblogs.com/codingmyworld/archive/2011/09/12/2174255.html" target="_blank" rel="external">这篇文章</a>后整理所得</p>
<p>在线程中有一个Looper对象，它内部维护了一个消息队列，且一个线程只能有一个Looper对象</p>
<p>因为Looper的prepare()方法的核心就是将looper对象定义为ThreadLocal</p>
<p>使用Looper类创建Looper线程很简单：</p>
<pre><code>public class LooperThread extends Thread {
        @Override
        public void run() {
        // 将当前线程初始化为Looper线程
        Looper.prepare();

        // ...其他处理，如实例化handler

        // 开始循环处理消息队列
        Looper.loop();
        }
 }

private static void prepare(boolean quitAllowed) {
    if (sThreadLocal.get() != null) {
        throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);
    }
    sThreadLocal.set(new Looper(quitAllowed));
}

关于ThreadLocal
 Implements a thread-local storage, that is, a variable for which each thread has 
 its own value. All threads share the same {@code ThreadLocal} object, but each 
 sees a different value when accessing it, and changes made by one thread do 
 not affect the other threads.
</code></pre><p>Loop()方法，调用loop方法后，Looper线程就开始工作了，不断从自己的MessageQueue中取出队头的消息执行</p>
<pre><code>/**
 * Run the message queue in this thread. Be sure to call
 * {@link #quit()} to end the loop.
 */
public static void loop() {
    final Looper me = myLooper();
    if (me == null) {
        throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&apos;t called on this thread.&quot;);
    }
    final MessageQueue queue = me.mQueue;

    // Make sure the identity of this thread is that of the local process,
    // and keep track of what that identity token actually is.
    Binder.clearCallingIdentity();
    final long ident = Binder.clearCallingIdentity();

    for (;;) {
        Message msg = queue.next(); // might block
        if (msg == null) {
            // No message indicates that the message queue is quitting.
            return;
        }

        // This must be in a local variable, in case a UI event sets the logger
        Printer logging = me.mLogging;
        if (logging != null) {
            logging.println(&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot; + msg.target + &quot; &quot; +
                    msg.callback + &quot;: &quot; + msg.what);
        }

        msg.target.dispatchMessage(msg);

        if (logging != null) {
            logging.println(&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback);
        }

        // Make sure that during the course of dispatching the
        // identity of the thread wasn&apos;t corrupted.
        final long newIdent = Binder.clearCallingIdentity();
        if (ident != newIdent) {
            Log.wtf(TAG, &quot;Thread identity changed from 0x&quot;
                    + Long.toHexString(ident) + &quot; to 0x&quot;
                    + Long.toHexString(newIdent) + &quot; while dispatching to &quot;
                    + msg.target.getClass().getName() + &quot; &quot;
                    + msg.callback + &quot; what=&quot; + msg.what);
        }

        msg.recycleUnchecked();
    }
}
</code></pre><p>关于Loopper的总结</p>
<ul>
<li>每个线程有且最多只能有一个Looper对象，它是一个ThreadLocal</li>
<li>Looper内部有一个消息队列，loop()方法调用后线程开始不断从队列中取出消息执行 msg.target.dispatchMessage(msg); 交由Handler来执行</li>
</ul>
<p>###Handler</p>
<p>Handler向MessageQueue添加消息，处理消息，只处理自己发出的消息，Handler创建的时候会关联一个Looper，默认的构造方法会关联当前线程的Looper。</p>
<pre><code>A Handler allows you to send and process {@link Message} and Runnableobjects associated 
with a thread&apos;s {@link MessageQueue}.  Each Handler instance is associated with a single thread 
and that thread&apos;s message queue.  When you create a new Handler, it is bound to the thread / message queue of the thread that is creating it -- 
from that point on, it will deliver messages and runnables to that message queue and execute them as they come out of the message queue. There are two main uses for a Handler: (1) to schedule messages and runnables to be executed as some point in the future; and (2) to enqueue an action to be performed on a different thread than your own.

public class Handler {

    final MessageQueue mQueue; //关联的MessageQueue
        final Looper mLooper; //关联的Looper
        final Callback mCallback; //回调函数

        public Handler(Callback callback, boolean async) {
    if (FIND_POTENTIAL_LEAKS) {
        final Class&lt;? extends Handler&gt; klass = getClass();
        if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;
                (klass.getModifiers() &amp; Modifier.STATIC) == 0) {
            Log.w(TAG, &quot;The following Handler class should be static or leaks might occur: &quot; +
                klass.getCanonicalName());
        }
    }
    // 默认将关联当前线程的looper
    mLooper = Looper.myLooper();
    if (mLooper == null) {
        throw new RuntimeException(
            &quot;Can&apos;t create handler inside thread that has not called Looper.prepare()&quot;);
    }
    // 重要！！！直接把关联looper的MQ作为自己的MQ，因此它的消息将发送到关联looper的MQ上
    mQueue = mLooper.mQueue;
    mCallback = callback;
    mAsynchronous = async;
}

}
</code></pre><p>下面我们就可以为之前的类加入Handler</p>
<pre><code>public class LooperThread extends Thread {
private Handler handler1;
private Handler handler2;

@Override
public void run() {
    // 将当前线程初始化为Looper线程
    Looper.prepare();

    // 实例化两个handler
    handler1 = new Handler();
    handler2 = new Handler();

    // 开始循环处理消息队列
    Looper.loop();
}
}
//一个线程可以有多个Handler，但是只能有一个Looper！
</code></pre><p>有了handler之后，我们就可以使用 post(Runnable), postAtTime(Runnable, long), postDelayed(Runnable, long), sendEmptyMessage(int), sendMessage(Message), sendMessageAtTime(Message, long)和 sendMessageDelayed(Message, long)这些方法向MQ上发送消息了。光看这些API你可能会觉得handler能发两种消息，一种是Runnable对象，一种是message对象，这是直观的理解，但其实post发出的Runnable对象最后都被封装成message对象了</p>
<p>Handler处理消息</p>
<p>消息的处理是通过核心方法dispatchMessage(Message msg)与钩子方法handleMessage(Message msg)完成的</p>
<pre><code>// 处理消息，该方法由looper调用
public void dispatchMessage(Message msg) {
    if (msg.callback != null) {
        // 如果message设置了callback，即runnable消息，处理callback！
        handleCallback(msg);
    } else {
        // 如果handler本身设置了callback，则执行callback
        if (mCallback != null) {
             /* 这种方法允许让activity等来实现Handler.Callback接口，避免了自己编写handler重写handleMessage方法。见http://alex-yang-xiansoftware-com.iteye.com/blog/850865 */
            if (mCallback.handleMessage(msg)) {
                return;
            }
        }
        // 如果message没有callback，则调用handler的钩子方法handleMessage
        handleMessage(msg);
    }
}

// 处理runnable消息
private final void handleCallback(Message message) {
    message.callback.run();  //直接调用run方法！
}
// 由子类实现的钩子方法
public void handleMessage(Message msg) {
}
</code></pre><p>Handler可以在任意线程发送消息，这些消息会被添加到关联的MessageQueue上</p>
<p>Handler是在它关联的looper线程中处理消息的</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/21/viewDispatchEvent/" itemprop="url">
                  View的事件分发机制
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-21T17:41:31+08:00" content="2016-05-21">
              2016-05-21
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/源码分析/" itemprop="url" rel="index">
                    <span itemprop="name">源码分析</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="View的事件分发机制"><a href="#View的事件分发机制" class="headerlink" title="View的事件分发机制"></a>View的事件分发机制</h3><p>该机制是解决View滑动冲突的核心理论</p>
<p>所谓的事件分发机制就是对MotionEvent的事件分发</p>
<p>View的事件分发由三个很重要的方法共同完成：</p>
<pre><code>//Pass the touch screen motion event down to the target view, or this view if it is the target.
dispatchTouchEvent(MotionEvent e)

//Implement this method to intercept all touch screen motion events.  This allows you to watch events as they are dispatched to your children, and take ownership of the current gesture at any point.
onInterceptTouchEvent(MotionEvent e)


onTouchEvent(MotionEvent e)
</code></pre><p>ViewGroup -&gt; ViewGroup -&gt; View </p>
<p>View onTouchEvent() -&gt; VIewGroup onTouchEvent() -&gt; ViewGroup onTouchEvent()</p>
<p>Activity -&gt; Window -&gt; decor view(当前界面的底层容器，即setContentView方法所设置的View的父容器)通过Activity.getWindow().getDecorView() 可以获得</p>
<p>Activity 的 dispatchTouchEvent()方法</p>
<pre><code>public boolean dispatchTouchEvent(MotionEvent ev) {
    if (ev.getAction() == MotionEvent.ACTION_DOWN) {
        onUserInteraction();
    }
    //首先交给Activity所属的Window来进行事件分发，如果返回True，则整个事件结束，如果返回false，意味着事件没人处理，所有View的onTouchEvent 都返回了false，则Activity的onTouchEvent就会被调用
    if (getWindow().superDispatchTouchEvent(ev)) {
        return true;
    }
    return onTouchEvent(ev);
}
</code></pre><p>接下来看一下Window是如何将事件传递给ViewGroup的</p>
<p>Window是抽象类，它的superDispatchTouchEvent是个抽象方法，它的唯一实现类是PhoneWindow</p>
<pre><code>@Override
public boolean superDispatchTouchEvent(MotionEvent event) {
//直接传递给了DecorView
 return mDecor.superDispatchTouchEvent(event);
}
</code></pre><p>最终通过DecorView传递到Activity setContentView() 方法中的View里</p>
<p>通过下面方法可以得到Activity所设置的View </p>
<pre><code>((ViewGroup)getWindow().getDecorView().findViewById(android.R.id.content)).getChildAt(0);
</code></pre><p>下面看一下ViewGroup的dispatchTouchEvent()方法</p>
<pre><code>// Check for interception.
final boolean intercepted;
if (actionMasked == MotionEvent.ACTION_DOWN
        || mFirstTouchTarget != null) {
    final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0;
    if (!disallowIntercept) {
        intercepted = onInterceptTouchEvent(ev);
        ev.setAction(action); // restore action in case it was changed
    } else {
        intercepted = false;
    }
} else {
    // There are no touch targets and this action is not an initial down
    // so this view group continues to intercept touches.
    intercepted = true;
}
</code></pre><p>  从上面的代码可以看出：当事件类型为ACTION_DOWN或者mFristTouchTarget != null时（事件由子元素成功处理，mFirstTouchTarget被赋值并指向子元素，此时mFristTouchTarget不为空，即一旦ViewGroup拦截当前事件，则mFristTouchTarget即为空） ，ViewGroup会进一步去调用onInterceptTouchEvent方法来判断是否需要拦截当前事件。那么，当ACTION_MOVE ACTION_UP事件到来时，上述两个条件不成立，导致ViewGroup的onInterceptTouchEvent方法不会再被调用，同一序列中的其他事件都会默认交给ViewGroup来处理。</p>
<p>  特殊情况：标记位：FLAG_DISALLOW_INTERCEPT，通过requestDisallowInterceptTouchEvent方法来设置，一般用于子View中，该标记位一旦设置后，ViewGroup将无法拦截除了ACTION_DOWN以外的其他点击事件（因为ACTION_DOWN会重置FLAG_DISALLOW_INTERCEPT，导致子View中设置的这个标记位无效。）</p>
<pre><code> // Handle an initial down.
if (actionMasked == MotionEvent.ACTION_DOWN) {
    // Throw away all previous state when starting a new touch gesture.
    // The framework may have dropped the up or cancel event for the previous gesture
    // due to an app switch, ANR, or some other state change.
    cancelAndClearTouchTargets(ev);
    resetTouchState(); //在该方法中对FLAG_DISALLOW_INTERCEPT进行重置
}
</code></pre><p>  所以FLAG_DISALLOW_INTERCEPT标志位的作用就是让ViewGroup不再拦截事件，当然前提是ViewGroup不拦截ActionDown事件。</p>
<p>  可见：（1）onInterceptTouchEvent方法不是每次都会被调用的，如果想提前处理所有的点击事件，要选择dispatchTouchEvent方法；</p>
<p>  （2）FLAG_DISALLOW_INTERCEPT提供了解决滑动冲突的思路</p>
<p>  ViewGroup不拦截事件，事件向下分发，交给它的子View进行处理：</p>
<pre><code>final View[] children = mChildren;
      for (int i = childrenCount - 1; i &gt;= 0; i--) {
          final int childIndex = customOrder
                  ? getChildDrawingOrder(childrenCount, i) : i;
          final View child = (preorderedList == null)
                  ? children[childIndex] : preorderedList.get(childIndex);

          // If there is a view that has accessibility focus we want it
          // to get the event first and if not handled we will perform a
          // normal dispatch. We may do a double iteration but this is
          // safer given the timeframe.
          if (childWithAccessibilityFocus != null) {
              if (childWithAccessibilityFocus != child) {
                  continue;
              }
              childWithAccessibilityFocus = null;
              i = childrenCount - 1;
          }

          if (!canViewReceivePointerEvents(child)
                  || !isTransformedTouchPointInView(x, y, child, null)) {
              ev.setTargetAccessibilityFocus(false);
              continue;
          }

          newTouchTarget = getTouchTarget(child);
          if (newTouchTarget != null) {
              // Child is already receiving touch within its bounds.
              // Give it the new pointer in addition to the ones it is handling.
              newTouchTarget.pointerIdBits |= idBitsToAssign;
              break;
          }

          resetCancelNextUpFlag(child);
          if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {
              // Child wants to receive touch within its bounds.
              mLastTouchDownTime = ev.getDownTime();
              if (preorderedList != null) {
                  // childIndex points into presorted list, find original index
                  for (int j = 0; j &lt; childrenCount; j++) {
                      if (children[childIndex] == mChildren[j]) {
                          mLastTouchDownIndex = j;
                          break;
                      }
                  }
              } else {
                  mLastTouchDownIndex = childIndex;
              }
              mLastTouchDownX = ev.getX();
              mLastTouchDownY = ev.getY();
              newTouchTarget = addTouchTarget(child, idBitsToAssign);
              alreadyDispatchedToNewTouchTarget = true;
              break;
          }
</code></pre><p> 上述代码的分析：首先遍历ViewGroup的所有子元素，然后判断子元素是否能够接收点击事件（即子元素是否在播放动画以及点击事件的坐标是否落在子元素的区域内），如果某个子元素满足这个条件，事件就会传递给它来处理。如果遍历所有的子元素后，事件都没有得到处理（ViewGroup没有子元素，子元素在onTouchEvent中返回了false）</p>
<p> View对点击事件的处理：单独的View无法向下传递事件，只能自己处理 </p>
<pre><code> public boolean dispatchTouchEvent(MotionEvent event) {
    // If the event should be handled by accessibility focus first.
    if (event.isTargetAccessibilityFocus()) {
        // We don&apos;t have focus or no virtual descendant has it, do not handle the event.
        if (!isAccessibilityFocusedViewOrHost()) {
            return false;
        }
        // We have focus and got the event, then use normal event dispatch.
        event.setTargetAccessibilityFocus(false);
    }

    boolean result = false;

    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTouchEvent(event, 0);
    }

    final int actionMasked = event.getActionMasked();
    if (actionMasked == MotionEvent.ACTION_DOWN) {
        // Defensive cleanup for new gesture
        stopNestedScroll();
    }

    if (onFilterTouchEventForSecurity(event)) {
        //noinspection SimplifiableIfStatement
        ListenerInfo li = mListenerInfo;
        if (li != null &amp;&amp; li.mOnTouchListener != null
                &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED
                &amp;&amp; li.mOnTouchListener.onTouch(this, event)) {
            result = true;
        }

        if (!result &amp;&amp; onTouchEvent(event)) {
            result = true;
        }
    }

    if (!result &amp;&amp; mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onUnhandledEvent(event, 0);
    }

    // Clean up after nested scrolls if this is the end of a gesture;
    // also cancel it if we tried an ACTION_DOWN but we didn&apos;t want the rest
    // of the gesture.
    if (actionMasked == MotionEvent.ACTION_UP ||
            actionMasked == MotionEvent.ACTION_CANCEL ||
            (actionMasked == MotionEvent.ACTION_DOWN &amp;&amp; !result)) {
        stopNestedScroll();
    }

    return result;
}

public boolean onTouchEvent(MotionEvent event) {
    final float x = event.getX();
    final float y = event.getY();
    final int viewFlags = mViewFlags;
    final int action = event.getAction();

    if ((viewFlags &amp; ENABLED_MASK) == DISABLED) {
        if (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != 0) {
            setPressed(false);
        }
        // A disabled view that is clickable still consumes the touch
        // events, it just doesn&apos;t respond to them.
        return (((viewFlags &amp; CLICKABLE) == CLICKABLE
                || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)
                || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE);
    }

    if (mTouchDelegate != null) {
        if (mTouchDelegate.onTouchEvent(event)) {
            return true;
        }
    }

    if (((viewFlags &amp; CLICKABLE) == CLICKABLE ||
            (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) ||
            (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE) {
        switch (action) {
            case MotionEvent.ACTION_UP:
                boolean prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != 0;
                if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0 || prepressed) {
                    // take focus if we don&apos;t have it already and we should in
                    // touch mode.
                    boolean focusTaken = false;
                    if (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) {
                        focusTaken = requestFocus();
                    }

                    if (prepressed) {
                        // The button is being released before we actually
                        // showed it as pressed.  Make it show the pressed
                        // state now (before scheduling the click) to ensure
                        // the user sees it.
                        setPressed(true, x, y);
                   }

                    if (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) {
                        // This is a tap, so remove the longpress check
                        removeLongPressCallback();

                        // Only perform take click actions if we were in the pressed state
                        if (!focusTaken) {
                            // Use a Runnable and post this rather than calling
                            // performClick directly. This lets other visual state
                            // of the view update before click actions start.
                            if (mPerformClick == null) {
                                mPerformClick = new PerformClick();
                            }
                            if (!post(mPerformClick)) {
                                performClick();
                            }
                        }
                    }

                    if (mUnsetPressedState == null) {
                        mUnsetPressedState = new UnsetPressedState();
                    }

                    if (prepressed) {
                        postDelayed(mUnsetPressedState,
                                ViewConfiguration.getPressedStateDuration());
                    } else if (!post(mUnsetPressedState)) {
                        // If the post failed, unpress right now
                        mUnsetPressedState.run();
                    }

                    removeTapCallback();
                }
                mIgnoreNextUpEvent = false;
                break;

            case MotionEvent.ACTION_DOWN:
                mHasPerformedLongPress = false;

                if (performButtonActionOnTouchDown(event)) {
                    break;
                }

                // Walk up the hierarchy to determine if we&apos;re inside a scrolling container.
                boolean isInScrollingContainer = isInScrollingContainer();

                // For views inside a scrolling container, delay the pressed feedback for
                // a short period in case this is a scroll.
                if (isInScrollingContainer) {
                    mPrivateFlags |= PFLAG_PREPRESSED;
                    if (mPendingCheckForTap == null) {
                        mPendingCheckForTap = new CheckForTap();
                    }
                    mPendingCheckForTap.x = event.getX();
                    mPendingCheckForTap.y = event.getY();
                    postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());
                } else {
                    // Not inside a scrolling container, so show the feedback right away
                    setPressed(true, x, y);
                    checkForLongClick(0);
                }
                break;

            case MotionEvent.ACTION_CANCEL:
                setPressed(false);
                removeTapCallback();
                removeLongPressCallback();
                mInContextButtonPress = false;
                mHasPerformedLongPress = false;
                mIgnoreNextUpEvent = false;
                break;

            case MotionEvent.ACTION_MOVE:
                drawableHotspotChanged(x, y);

                // Be lenient about moving outside of buttons
                if (!pointInView(x, y, mTouchSlop)) {
                    // Outside button
                    removeTapCallback();
                    if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0) {
                        // Remove any future long press/tap checks
                        removeLongPressCallback();

                        setPressed(false);
                    }
                }
                break;
        }

        return true;
    }

    return false;
}
</code></pre><p>以上全文是学习 <a href="http://item.jd.com/11760209.html" target="_blank" rel="external">《Android开发艺术探索》</a> 后的笔记    </p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/21/scroller/" itemprop="url">
                  Scroller源码分析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-21T17:37:40+08:00" content="2016-05-21">
              2016-05-21
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/源码分析/" itemprop="url" rel="index">
                    <span itemprop="name">源码分析</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Scroller"><a href="#Scroller" class="headerlink" title="Scroller"></a>Scroller</h3><p>View类的方法是个空函数，实现自定义View的滑动就需要手动去复写该方法</p>
<pre><code>/** 
 * Called by a parent to request that a child update its values for mScrollX 
 * and mScrollY if necessary. This will typically be done if the child is 
 * animating a scroll using a {@link android.widget.Scroller Scroller} 
 * object. 
 */
public void computeScroll() 
{ 
}
</code></pre><p>那么：computeScroll()是怎样被调用的呢？看一下ViewGroup的源码</p>
<pre><code>@Override 
  protected void dispatchDraw(Canvas canvas) { 

      ....... 

      ....... 

      ....... 

      ....... 

     for (int i = 0; i &lt; childrenCount; i++) {
    while (transientIndex &gt;= 0 &amp;&amp; mTransientIndices.get(transientIndex) == i) {
        final View transientChild = mTransientViews.get(transientIndex);
        if ((transientChild.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE ||
                transientChild.getAnimation() != null) {
            more |= drawChild(canvas, transientChild, drawingTime);
        }
        transientIndex++;
        if (transientIndex &gt;= transientCount) {
            transientIndex = -1;
        }
    }
    int childIndex = customOrder ? getChildDrawingOrder(childrenCount, i) : i;
    final View child = (preorderedList == null)
            ? children[childIndex] : preorderedList.get(childIndex);
    if ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || child.getAnimation() != null) {
        more |= drawChild(canvas, child, drawingTime);
    }
}

      ....... 

      ....... 

      ....... 
  }
</code></pre><p>ViewGroup 在dispatchDraw()函数中对它的每一个孩子调用drawChild()，再看看drawChild()方法</p>
<pre><code>protected boolean drawChild(Canvas canvas, View child, long drawingTime) {
    return child.draw(canvas, this, drawingTime);
}
</code></pre><p>调用的child的draw方法 在draw()方法中，会调用computeScroll();</p>
<pre><code> private void smoothScrollBy(int dx, int dy) {
    mScroller.startScroll(getScrollX(), 0, dx, 0, 500);
    invalidate();
}

@Override
public void computeScroll() {
    if (mScroller.computeScrollOffset()) {
        scrollTo(mScroller.getCurrX(), mScroller.getCurrY());
        postInvalidate();
    }
}
</code></pre><p>Scroller 的startScroll方法只是保存了一些参数，单靠startScroll是无法发生滑动的，关键在于invalidate方法，导致重绘，重绘的时候，View的draw方法会调用computeScroll，computeScroll是空方法，我们自己来实现，比如在computeScroll中调用scrollTo方法就可以使得View产生滑动效果，然后再调用postInvalidate方法来进行第二次重绘，如此反复，直到整个滑动过程结束 参见《Android开发艺术探索》第三章 至于mScroller.computeScrollOffset()的方法：</p>
<pre><code>public boolean computeScrollOffset() {
    if (mFinished) {
        return false;
    }

    int timePassed = (int)(AnimationUtils.currentAnimationTimeMillis() - mStartTime);

    if (timePassed &lt; mDuration) {
        switch (mMode) {
        case SCROLL_MODE:
            final float x = mInterpolator.getInterpolation(timePassed * mDurationReciprocal);
            mCurrX = mStartX + Math.round(x * mDeltaX);
            mCurrY = mStartY + Math.round(x * mDeltaY);
            break;
        case FLING_MODE:
            final float t = (float) timePassed / mDuration;
            final int index = (int) (NB_SAMPLES * t);
            float distanceCoef = 1.f;
            float velocityCoef = 0.f;
            if (index &lt; NB_SAMPLES) {
                final float t_inf = (float) index / NB_SAMPLES;
                final float t_sup = (float) (index + 1) / NB_SAMPLES;
                final float d_inf = SPLINE_POSITION[index];
                final float d_sup = SPLINE_POSITION[index + 1];
                velocityCoef = (d_sup - d_inf) / (t_sup - t_inf);
                distanceCoef = d_inf + (t - t_inf) * velocityCoef;
            }

            mCurrVelocity = velocityCoef * mDistance / mDuration * 1000.0f;

            mCurrX = mStartX + Math.round(distanceCoef * (mFinalX - mStartX));
            // Pin to mMinX &lt;= mCurrX &lt;= mMaxX
            mCurrX = Math.min(mCurrX, mMaxX);
            mCurrX = Math.max(mCurrX, mMinX);

            mCurrY = mStartY + Math.round(distanceCoef * (mFinalY - mStartY));
            // Pin to mMinY &lt;= mCurrY &lt;= mMaxY
            mCurrY = Math.min(mCurrY, mMaxY);
            mCurrY = Math.max(mCurrY, mMinY);

            if (mCurrX == mFinalX &amp;&amp; mCurrY == mFinalY) {
                mFinished = true;
            }

            break;
        }
    }
    else {
        mCurrX = mFinalX;
        mCurrY = mFinalY;
        mFinished = true;
    }
    return true;
}
</code></pre><p>该方法的功能是随着时间的流逝，计算当前的scrollX和scrollY的值，相当于差之器的概念，根据时间流逝的百分比来计算，返回true，表示滑动未技术，返回false表示滑动结束</p>
<p>Scroller原理概括：Scroller本身并不能实现滑动，它需要配合View的computeScroll的方法才能完成弹性滑动的效果，它不断的让View重绘，而每一次重绘距滑动起始时间会有一个时间间隔，通过这个时间间隔，Scroller可以得到View当前的滑动位置，这样，View每次重绘都会导致View进行小幅度的移动，而多次的小幅度的移动就形成了弹性滑动。Scroller的设计很精妙，整个过程中，他对View没有丝毫的引用，甚至在它内部连计时器都没有。</p>
<p>参考 <a href="http://item.jd.com/11760209.html" target="_blank" rel="external">《Android开发艺术探索》</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/21/androidCodeAnsys/" itemprop="url">
                  《Android系统源代码情景分析》学习笔记1 Activity 组件的启动过程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-21T17:35:11+08:00" content="2016-05-21">
              2016-05-21
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/源码分析/" itemprop="url" rel="index">
                    <span itemprop="name">源码分析</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="《Android系统源代码情景分析》学习笔记1-Activity-组件的启动过程"><a href="#《Android系统源代码情景分析》学习笔记1-Activity-组件的启动过程" class="headerlink" title="《Android系统源代码情景分析》学习笔记1 Activity 组件的启动过程"></a>《Android系统源代码情景分析》学习笔记1 Activity 组件的启动过程</h3><blockquote>
<p>Activity 组件的启动过程</p>
</blockquote>
<p>MainActivity的android:process 属性设置为 “mainprocess”, Activity是通过Launcher组件来启动的，Launcher组件通过 Activity 管理服务ActivityManagerService来启动Activity ，ActivityManagerService在启动MainActivity组件时，就会发现系统中并不存在一个“mainprocess”进程，这是它就会先创建这个应用程序的进程，然后再讲MainActivity的组件启动起来；</p>
<p>由于MainActivity、Launcher、ActivityManagerService三者分别运行在不同的进程中，因此MainActivity的启动过程就涉及到了三个进程，这三个进程是通过Binder进程间通信机制来完成MainActivity组件的启动过程的。</p>
<p>Launcher组件启动MainActivity组件的过程如下：</p>
<p>（1）Launcher组件向ActivityManagerService发送一个启动MainActivity组件的进程间通信请求；</p>
<p>（2）ActivityManagerService首先将要启动的MainActivity的组件信息保存下来，然后再向launcher组件发送一个进入终止状态的进程间通信请求；</p>
<p>（3）Launcher组件进入终止状态后，就会向ActivityManagerService发送一个已进入终止状态的进程间通信请求，以便于ActivityManagerService继续执行启动MainActivity组件的操作；</p>
<p>（4）ActivityManagerService发现用来运行MainActivity组件的应用程序进程不存在，因此，它就会先启动一个新的应用程序进程；</p>
<p>（5）新的应用程序进程启动完成后，就会向ActivityManagerService发送一个启动完成的进程间通信，以便于ActivityManagerService继续执行启动MainActivity组件的操作；</p>
<p>（6）ActivityManagerService将保存下来的MainActivity的组件信息发送给刚刚为MainActivity创建的进程，以便于它将MainActivity组件启动起来。</p>
<p>这个过程共细分为35个步骤，下面进行详解：</p>
<pre><code>boolean startActivitySafely(View v, Intent intent, Object tag) {
    boolean success = false;
    try {
        success = startActivity(v, intent, tag);
    } catch (ActivityNotFoundException e) {
        Toast.makeText(this, R.string.activity_not_found, Toast.LENGTH_SHORT).show();
        Log.e(TAG, &quot;Unable to launch. tag=&quot; + tag + &quot; intent=&quot; + intent, e);
    }
         return success;
}
</code></pre><p>（1）当我们点击应用程序的快捷图标的时候，Launcher组件的成员函数startActivitySafely就会被调用来启动这个应用程序的根Activity，其中，要启动的信息包含在参数intent中。</p>
<p>那Launcher组件是如何获取这些信息的呢：系统启动的时候，会启动一个Package管理服务，PackageManagerService，并通过它来安装系统中的应用程序，PackageManagerService在安装一个应用程序的时候，会对它的AndroidManifest.xml文件进行解析，从而得到它里面的组件信息。系统启动完成之后，就会将Launcher组件启动起来，Launcher在启动的过程中，会想PackageManagerService查询有所Action名称=“Intent.ACTION_MAIN”并且Category=”Intent.CATEGORY_LAUNCHER”的Activity组件，最后为每一个Activity组件创建一个快捷图标，并将他们的信息与快捷图标关联起来。</p>
<pre><code>public void startActivityForResult(Intent intent, int requestCode, @Nullable Bundle options) {
 if (mParent == null) {
    Instrumentation.ActivityResult ar = mInstrumentation.execStartActivity(
    this, mMainThread.getApplicationThread(), mToken, this,ntent, requestCode, options);
    if (ar != null) {
    mMainThread.sendActivityResult(
    mToken, mEmbeddedID, requestCode, ar.getResultCode(),ar.getResultData());
 }
...
</code></pre><p>（2）Instrumentation:用来监控应用程序和系统之间的交互操作，因此调用Instrumentation的execStartActivity来代为执行Activity的组件操作，以便它可以监控这个交互过程。</p>
<p>execStartActivity()的几个参数： </p>
<p>mMainThread：类型为ActivityThead，用来描述一个应用程序进程，系统每当启动一个应用程序的时候，都会在这个应用程序里面加载一个ActivityThead类实例，这个实例保存在该进程中启动的Activity组件的父类Activity的成员变量mMainThread中。而ActivityThead的getApplicationThread()方法，用来获取它内部的一个类型为ApplicationThread的Binder本地对象。由于Launcher是Activity的子类，通过mMainThread.getApplicationThread()将Launcher所运行在的进程ActivityThead实例传递给mInstrumentation的方法execStartActivity()以便于可以将它传递给ActivityManagerService，这样ActivityManagerService接下来就可以通知Launcher组件进入Paused状态了；</p>
<p>mToken：类型为IBinder，是一个Binder的代理对象，指向了一个ActivityManagerService中一个类型为ActivityRecord的Binder本地对象。每个启动的Activity组件在ActivityManagerService中都有一个对应的ActivityRecord对象，用来维护对应的Activity组件的运行状态以及信息。将mToken传递给ActivityManagerService，以便于ActivityManagerService获取Launcher组件的详细信息；</p>
<pre><code>public ActivityResult execStartActivity(Context who, IBinder contextThread, 
IBinder token, Activity target,Intent intent, int requestCode, Bundle options) {
...

try {
    intent.migrateExtraStreamToClipData();
    intent.prepareToLeaveProcess();
     int result = ActivityManagerNative.getDefault().startActivity(whoThread,who.getBasePackageName(), intent,intent.resolveTypeIfNeeded(who.getContentResolver()),token, target != null ? target.mEmbeddedID : null,requestCode, 0, null, options);
    checkStartActivityResult(result, intent);
    } catch (RemoteException e) {
    }
    return null;
}
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/avatar.jpg"
               alt="ADwangyang" />
          <p class="site-author-name" itemprop="name">ADwangyang</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/">
              <span class="site-state-item-count">14</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">6</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">10</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ADwangyang</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  



  
  
  

  

  

</body>
</html>
