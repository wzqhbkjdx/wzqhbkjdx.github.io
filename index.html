<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="风车老家">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="风车老家">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="风车老家">
<meta name="twitter:description">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"always"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> 风车老家 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">风车老家</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/21/handler/" itemprop="url">
                  Handler、Looper
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-21T17:46:00+08:00" content="2016-05-21">
              2016-05-21
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/源码分析/" itemprop="url" rel="index">
                    <span itemprop="name">源码分析</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Handler、Looper"><a href="#Handler、Looper" class="headerlink" title="Handler、Looper"></a>Handler、Looper</h3><p>学习了<a href="http://www.cnblogs.com/codingmyworld/archive/2011/09/12/2174255.html" target="_blank" rel="external">这篇文章</a>后整理所得</p>
<p>在线程中有一个Looper对象，它内部维护了一个消息队列，且一个线程只能有一个Looper对象</p>
<p>因为Looper的prepare()方法的核心就是将looper对象定义为ThreadLocal</p>
<p>使用Looper类创建Looper线程很简单：</p>
<pre><code>public class LooperThread extends Thread {
        @Override
        public void run() {
        // 将当前线程初始化为Looper线程
        Looper.prepare();

        // ...其他处理，如实例化handler

        // 开始循环处理消息队列
        Looper.loop();
        }
 }

private static void prepare(boolean quitAllowed) {
    if (sThreadLocal.get() != null) {
        throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);
    }
    sThreadLocal.set(new Looper(quitAllowed));
}

关于ThreadLocal
 Implements a thread-local storage, that is, a variable for which each thread has 
 its own value. All threads share the same {@code ThreadLocal} object, but each 
 sees a different value when accessing it, and changes made by one thread do 
 not affect the other threads.
</code></pre><p>Loop()方法，调用loop方法后，Looper线程就开始工作了，不断从自己的MessageQueue中取出队头的消息执行</p>
<pre><code>/**
 * Run the message queue in this thread. Be sure to call
 * {@link #quit()} to end the loop.
 */
public static void loop() {
    final Looper me = myLooper();
    if (me == null) {
        throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&apos;t called on this thread.&quot;);
    }
    final MessageQueue queue = me.mQueue;

    // Make sure the identity of this thread is that of the local process,
    // and keep track of what that identity token actually is.
    Binder.clearCallingIdentity();
    final long ident = Binder.clearCallingIdentity();

    for (;;) {
        Message msg = queue.next(); // might block
        if (msg == null) {
            // No message indicates that the message queue is quitting.
            return;
        }

        // This must be in a local variable, in case a UI event sets the logger
        Printer logging = me.mLogging;
        if (logging != null) {
            logging.println(&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot; + msg.target + &quot; &quot; +
                    msg.callback + &quot;: &quot; + msg.what);
        }

        msg.target.dispatchMessage(msg);

        if (logging != null) {
            logging.println(&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback);
        }

        // Make sure that during the course of dispatching the
        // identity of the thread wasn&apos;t corrupted.
        final long newIdent = Binder.clearCallingIdentity();
        if (ident != newIdent) {
            Log.wtf(TAG, &quot;Thread identity changed from 0x&quot;
                    + Long.toHexString(ident) + &quot; to 0x&quot;
                    + Long.toHexString(newIdent) + &quot; while dispatching to &quot;
                    + msg.target.getClass().getName() + &quot; &quot;
                    + msg.callback + &quot; what=&quot; + msg.what);
        }

        msg.recycleUnchecked();
    }
}
</code></pre><p>关于Loopper的总结</p>
<ul>
<li>每个线程有且最多只能有一个Looper对象，它是一个ThreadLocal</li>
<li>Looper内部有一个消息队列，loop()方法调用后线程开始不断从队列中取出消息执行 msg.target.dispatchMessage(msg); 交由Handler来执行</li>
</ul>
<p>###Handler</p>
<p>Handler向MessageQueue添加消息，处理消息，只处理自己发出的消息，Handler创建的时候会关联一个Looper，默认的构造方法会关联当前线程的Looper。</p>
<pre><code>A Handler allows you to send and process {@link Message} and Runnableobjects associated 
with a thread&apos;s {@link MessageQueue}.  Each Handler instance is associated with a single thread 
and that thread&apos;s message queue.  When you create a new Handler, it is bound to the thread / message queue of the thread that is creating it -- 
from that point on, it will deliver messages and runnables to that message queue and execute them as they come out of the message queue. There are two main uses for a Handler: (1) to schedule messages and runnables to be executed as some point in the future; and (2) to enqueue an action to be performed on a different thread than your own.

public class Handler {

    final MessageQueue mQueue; //关联的MessageQueue
        final Looper mLooper; //关联的Looper
        final Callback mCallback; //回调函数

        public Handler(Callback callback, boolean async) {
    if (FIND_POTENTIAL_LEAKS) {
        final Class&lt;? extends Handler&gt; klass = getClass();
        if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;
                (klass.getModifiers() &amp; Modifier.STATIC) == 0) {
            Log.w(TAG, &quot;The following Handler class should be static or leaks might occur: &quot; +
                klass.getCanonicalName());
        }
    }
    // 默认将关联当前线程的looper
    mLooper = Looper.myLooper();
    if (mLooper == null) {
        throw new RuntimeException(
            &quot;Can&apos;t create handler inside thread that has not called Looper.prepare()&quot;);
    }
    // 重要！！！直接把关联looper的MQ作为自己的MQ，因此它的消息将发送到关联looper的MQ上
    mQueue = mLooper.mQueue;
    mCallback = callback;
    mAsynchronous = async;
}

}
</code></pre><p>下面我们就可以为之前的类加入Handler</p>
<pre><code>public class LooperThread extends Thread {
private Handler handler1;
private Handler handler2;

@Override
public void run() {
    // 将当前线程初始化为Looper线程
    Looper.prepare();

    // 实例化两个handler
    handler1 = new Handler();
    handler2 = new Handler();

    // 开始循环处理消息队列
    Looper.loop();
}
}
//一个线程可以有多个Handler，但是只能有一个Looper！
</code></pre><p>有了handler之后，我们就可以使用 post(Runnable), postAtTime(Runnable, long), postDelayed(Runnable, long), sendEmptyMessage(int), sendMessage(Message), sendMessageAtTime(Message, long)和 sendMessageDelayed(Message, long)这些方法向MQ上发送消息了。光看这些API你可能会觉得handler能发两种消息，一种是Runnable对象，一种是message对象，这是直观的理解，但其实post发出的Runnable对象最后都被封装成message对象了</p>
<p>Handler处理消息</p>
<p>消息的处理是通过核心方法dispatchMessage(Message msg)与钩子方法handleMessage(Message msg)完成的</p>
<pre><code>// 处理消息，该方法由looper调用
public void dispatchMessage(Message msg) {
    if (msg.callback != null) {
        // 如果message设置了callback，即runnable消息，处理callback！
        handleCallback(msg);
    } else {
        // 如果handler本身设置了callback，则执行callback
        if (mCallback != null) {
             /* 这种方法允许让activity等来实现Handler.Callback接口，避免了自己编写handler重写handleMessage方法。见http://alex-yang-xiansoftware-com.iteye.com/blog/850865 */
            if (mCallback.handleMessage(msg)) {
                return;
            }
        }
        // 如果message没有callback，则调用handler的钩子方法handleMessage
        handleMessage(msg);
    }
}

// 处理runnable消息
private final void handleCallback(Message message) {
    message.callback.run();  //直接调用run方法！
}
// 由子类实现的钩子方法
public void handleMessage(Message msg) {
}
</code></pre><p>Handler可以在任意线程发送消息，这些消息会被添加到关联的MessageQueue上</p>
<p>Handler是在它关联的looper线程中处理消息的</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/21/viewDispatchEvent/" itemprop="url">
                  View的事件分发机制
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-21T17:41:31+08:00" content="2016-05-21">
              2016-05-21
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/源码分析/" itemprop="url" rel="index">
                    <span itemprop="name">源码分析</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="View的事件分发机制"><a href="#View的事件分发机制" class="headerlink" title="View的事件分发机制"></a>View的事件分发机制</h3><p>该机制是解决View滑动冲突的核心理论</p>
<p>所谓的事件分发机制就是对MotionEvent的事件分发</p>
<p>View的事件分发由三个很重要的方法共同完成：</p>
<pre><code>//Pass the touch screen motion event down to the target view, or this view if it is the target.
dispatchTouchEvent(MotionEvent e)

//Implement this method to intercept all touch screen motion events.  This allows you to watch events as they are dispatched to your children, and take ownership of the current gesture at any point.
onInterceptTouchEvent(MotionEvent e)


onTouchEvent(MotionEvent e)
</code></pre><p>ViewGroup -&gt; ViewGroup -&gt; View </p>
<p>View onTouchEvent() -&gt; VIewGroup onTouchEvent() -&gt; ViewGroup onTouchEvent()</p>
<p>Activity -&gt; Window -&gt; decor view(当前界面的底层容器，即setContentView方法所设置的View的父容器)通过Activity.getWindow().getDecorView() 可以获得</p>
<p>Activity 的 dispatchTouchEvent()方法</p>
<pre><code>public boolean dispatchTouchEvent(MotionEvent ev) {
    if (ev.getAction() == MotionEvent.ACTION_DOWN) {
        onUserInteraction();
    }
    //首先交给Activity所属的Window来进行事件分发，如果返回True，则整个事件结束，如果返回false，意味着事件没人处理，所有View的onTouchEvent 都返回了false，则Activity的onTouchEvent就会被调用
    if (getWindow().superDispatchTouchEvent(ev)) {
        return true;
    }
    return onTouchEvent(ev);
}
</code></pre><p>接下来看一下Window是如何将事件传递给ViewGroup的</p>
<p>Window是抽象类，它的superDispatchTouchEvent是个抽象方法，它的唯一实现类是PhoneWindow</p>
<pre><code>@Override
public boolean superDispatchTouchEvent(MotionEvent event) {
//直接传递给了DecorView
 return mDecor.superDispatchTouchEvent(event);
}
</code></pre><p>最终通过DecorView传递到Activity setContentView() 方法中的View里</p>
<p>通过下面方法可以得到Activity所设置的View </p>
<pre><code>((ViewGroup)getWindow().getDecorView().findViewById(android.R.id.content)).getChildAt(0);
</code></pre><p>下面看一下ViewGroup的dispatchTouchEvent()方法</p>
<pre><code>// Check for interception.
final boolean intercepted;
if (actionMasked == MotionEvent.ACTION_DOWN
        || mFirstTouchTarget != null) {
    final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0;
    if (!disallowIntercept) {
        intercepted = onInterceptTouchEvent(ev);
        ev.setAction(action); // restore action in case it was changed
    } else {
        intercepted = false;
    }
} else {
    // There are no touch targets and this action is not an initial down
    // so this view group continues to intercept touches.
    intercepted = true;
}
</code></pre><p>  从上面的代码可以看出：当事件类型为ACTION_DOWN或者mFristTouchTarget != null时（事件由子元素成功处理，mFirstTouchTarget被赋值并指向子元素，此时mFristTouchTarget不为空，即一旦ViewGroup拦截当前事件，则mFristTouchTarget即为空） ，ViewGroup会进一步去调用onInterceptTouchEvent方法来判断是否需要拦截当前事件。那么，当ACTION_MOVE ACTION_UP事件到来时，上述两个条件不成立，导致ViewGroup的onInterceptTouchEvent方法不会再被调用，同一序列中的其他事件都会默认交给ViewGroup来处理。</p>
<p>  特殊情况：标记位：FLAG_DISALLOW_INTERCEPT，通过requestDisallowInterceptTouchEvent方法来设置，一般用于子View中，该标记位一旦设置后，ViewGroup将无法拦截除了ACTION_DOWN以外的其他点击事件（因为ACTION_DOWN会重置FLAG_DISALLOW_INTERCEPT，导致子View中设置的这个标记位无效。）</p>
<pre><code> // Handle an initial down.
if (actionMasked == MotionEvent.ACTION_DOWN) {
    // Throw away all previous state when starting a new touch gesture.
    // The framework may have dropped the up or cancel event for the previous gesture
    // due to an app switch, ANR, or some other state change.
    cancelAndClearTouchTargets(ev);
    resetTouchState(); //在该方法中对FLAG_DISALLOW_INTERCEPT进行重置
}
</code></pre><p>  所以FLAG_DISALLOW_INTERCEPT标志位的作用就是让ViewGroup不再拦截事件，当然前提是ViewGroup不拦截ActionDown事件。</p>
<p>  可见：（1）onInterceptTouchEvent方法不是每次都会被调用的，如果想提前处理所有的点击事件，要选择dispatchTouchEvent方法；</p>
<p>  （2）FLAG_DISALLOW_INTERCEPT提供了解决滑动冲突的思路</p>
<p>  ViewGroup不拦截事件，事件向下分发，交给它的子View进行处理：</p>
<pre><code>final View[] children = mChildren;
      for (int i = childrenCount - 1; i &gt;= 0; i--) {
          final int childIndex = customOrder
                  ? getChildDrawingOrder(childrenCount, i) : i;
          final View child = (preorderedList == null)
                  ? children[childIndex] : preorderedList.get(childIndex);

          // If there is a view that has accessibility focus we want it
          // to get the event first and if not handled we will perform a
          // normal dispatch. We may do a double iteration but this is
          // safer given the timeframe.
          if (childWithAccessibilityFocus != null) {
              if (childWithAccessibilityFocus != child) {
                  continue;
              }
              childWithAccessibilityFocus = null;
              i = childrenCount - 1;
          }

          if (!canViewReceivePointerEvents(child)
                  || !isTransformedTouchPointInView(x, y, child, null)) {
              ev.setTargetAccessibilityFocus(false);
              continue;
          }

          newTouchTarget = getTouchTarget(child);
          if (newTouchTarget != null) {
              // Child is already receiving touch within its bounds.
              // Give it the new pointer in addition to the ones it is handling.
              newTouchTarget.pointerIdBits |= idBitsToAssign;
              break;
          }

          resetCancelNextUpFlag(child);
          if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {
              // Child wants to receive touch within its bounds.
              mLastTouchDownTime = ev.getDownTime();
              if (preorderedList != null) {
                  // childIndex points into presorted list, find original index
                  for (int j = 0; j &lt; childrenCount; j++) {
                      if (children[childIndex] == mChildren[j]) {
                          mLastTouchDownIndex = j;
                          break;
                      }
                  }
              } else {
                  mLastTouchDownIndex = childIndex;
              }
              mLastTouchDownX = ev.getX();
              mLastTouchDownY = ev.getY();
              newTouchTarget = addTouchTarget(child, idBitsToAssign);
              alreadyDispatchedToNewTouchTarget = true;
              break;
          }
</code></pre><p> 上述代码的分析：首先遍历ViewGroup的所有子元素，然后判断子元素是否能够接收点击事件（即子元素是否在播放动画以及点击事件的坐标是否落在子元素的区域内），如果某个子元素满足这个条件，事件就会传递给它来处理。如果遍历所有的子元素后，事件都没有得到处理（ViewGroup没有子元素，子元素在onTouchEvent中返回了false）</p>
<p> View对点击事件的处理：单独的View无法向下传递事件，只能自己处理 </p>
<pre><code> public boolean dispatchTouchEvent(MotionEvent event) {
    // If the event should be handled by accessibility focus first.
    if (event.isTargetAccessibilityFocus()) {
        // We don&apos;t have focus or no virtual descendant has it, do not handle the event.
        if (!isAccessibilityFocusedViewOrHost()) {
            return false;
        }
        // We have focus and got the event, then use normal event dispatch.
        event.setTargetAccessibilityFocus(false);
    }

    boolean result = false;

    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTouchEvent(event, 0);
    }

    final int actionMasked = event.getActionMasked();
    if (actionMasked == MotionEvent.ACTION_DOWN) {
        // Defensive cleanup for new gesture
        stopNestedScroll();
    }

    if (onFilterTouchEventForSecurity(event)) {
        //noinspection SimplifiableIfStatement
        ListenerInfo li = mListenerInfo;
        if (li != null &amp;&amp; li.mOnTouchListener != null
                &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED
                &amp;&amp; li.mOnTouchListener.onTouch(this, event)) {
            result = true;
        }

        if (!result &amp;&amp; onTouchEvent(event)) {
            result = true;
        }
    }

    if (!result &amp;&amp; mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onUnhandledEvent(event, 0);
    }

    // Clean up after nested scrolls if this is the end of a gesture;
    // also cancel it if we tried an ACTION_DOWN but we didn&apos;t want the rest
    // of the gesture.
    if (actionMasked == MotionEvent.ACTION_UP ||
            actionMasked == MotionEvent.ACTION_CANCEL ||
            (actionMasked == MotionEvent.ACTION_DOWN &amp;&amp; !result)) {
        stopNestedScroll();
    }

    return result;
}

public boolean onTouchEvent(MotionEvent event) {
    final float x = event.getX();
    final float y = event.getY();
    final int viewFlags = mViewFlags;
    final int action = event.getAction();

    if ((viewFlags &amp; ENABLED_MASK) == DISABLED) {
        if (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != 0) {
            setPressed(false);
        }
        // A disabled view that is clickable still consumes the touch
        // events, it just doesn&apos;t respond to them.
        return (((viewFlags &amp; CLICKABLE) == CLICKABLE
                || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)
                || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE);
    }

    if (mTouchDelegate != null) {
        if (mTouchDelegate.onTouchEvent(event)) {
            return true;
        }
    }

    if (((viewFlags &amp; CLICKABLE) == CLICKABLE ||
            (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) ||
            (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE) {
        switch (action) {
            case MotionEvent.ACTION_UP:
                boolean prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != 0;
                if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0 || prepressed) {
                    // take focus if we don&apos;t have it already and we should in
                    // touch mode.
                    boolean focusTaken = false;
                    if (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) {
                        focusTaken = requestFocus();
                    }

                    if (prepressed) {
                        // The button is being released before we actually
                        // showed it as pressed.  Make it show the pressed
                        // state now (before scheduling the click) to ensure
                        // the user sees it.
                        setPressed(true, x, y);
                   }

                    if (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) {
                        // This is a tap, so remove the longpress check
                        removeLongPressCallback();

                        // Only perform take click actions if we were in the pressed state
                        if (!focusTaken) {
                            // Use a Runnable and post this rather than calling
                            // performClick directly. This lets other visual state
                            // of the view update before click actions start.
                            if (mPerformClick == null) {
                                mPerformClick = new PerformClick();
                            }
                            if (!post(mPerformClick)) {
                                performClick();
                            }
                        }
                    }

                    if (mUnsetPressedState == null) {
                        mUnsetPressedState = new UnsetPressedState();
                    }

                    if (prepressed) {
                        postDelayed(mUnsetPressedState,
                                ViewConfiguration.getPressedStateDuration());
                    } else if (!post(mUnsetPressedState)) {
                        // If the post failed, unpress right now
                        mUnsetPressedState.run();
                    }

                    removeTapCallback();
                }
                mIgnoreNextUpEvent = false;
                break;

            case MotionEvent.ACTION_DOWN:
                mHasPerformedLongPress = false;

                if (performButtonActionOnTouchDown(event)) {
                    break;
                }

                // Walk up the hierarchy to determine if we&apos;re inside a scrolling container.
                boolean isInScrollingContainer = isInScrollingContainer();

                // For views inside a scrolling container, delay the pressed feedback for
                // a short period in case this is a scroll.
                if (isInScrollingContainer) {
                    mPrivateFlags |= PFLAG_PREPRESSED;
                    if (mPendingCheckForTap == null) {
                        mPendingCheckForTap = new CheckForTap();
                    }
                    mPendingCheckForTap.x = event.getX();
                    mPendingCheckForTap.y = event.getY();
                    postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());
                } else {
                    // Not inside a scrolling container, so show the feedback right away
                    setPressed(true, x, y);
                    checkForLongClick(0);
                }
                break;

            case MotionEvent.ACTION_CANCEL:
                setPressed(false);
                removeTapCallback();
                removeLongPressCallback();
                mInContextButtonPress = false;
                mHasPerformedLongPress = false;
                mIgnoreNextUpEvent = false;
                break;

            case MotionEvent.ACTION_MOVE:
                drawableHotspotChanged(x, y);

                // Be lenient about moving outside of buttons
                if (!pointInView(x, y, mTouchSlop)) {
                    // Outside button
                    removeTapCallback();
                    if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0) {
                        // Remove any future long press/tap checks
                        removeLongPressCallback();

                        setPressed(false);
                    }
                }
                break;
        }

        return true;
    }

    return false;
}
</code></pre><p>参考 <a href="http://item.jd.com/11760209.html" target="_blank" rel="external">《Android开发艺术探索》</a>    </p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/21/scroller/" itemprop="url">
                  Scroller源码分析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-21T17:37:40+08:00" content="2016-05-21">
              2016-05-21
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/源码分析/" itemprop="url" rel="index">
                    <span itemprop="name">源码分析</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Scroller"><a href="#Scroller" class="headerlink" title="Scroller"></a>Scroller</h3><p>View类的方法是个空函数，实现自定义View的滑动就需要手动去复写该方法</p>
<pre><code>/** 
 * Called by a parent to request that a child update its values for mScrollX 
 * and mScrollY if necessary. This will typically be done if the child is 
 * animating a scroll using a {@link android.widget.Scroller Scroller} 
 * object. 
 */
public void computeScroll() 
{ 
}
</code></pre><p>那么：computeScroll()是怎样被调用的呢？看一下ViewGroup的源码</p>
<pre><code>@Override 
  protected void dispatchDraw(Canvas canvas) { 

      ....... 

      ....... 

      ....... 

      ....... 

     for (int i = 0; i &lt; childrenCount; i++) {
    while (transientIndex &gt;= 0 &amp;&amp; mTransientIndices.get(transientIndex) == i) {
        final View transientChild = mTransientViews.get(transientIndex);
        if ((transientChild.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE ||
                transientChild.getAnimation() != null) {
            more |= drawChild(canvas, transientChild, drawingTime);
        }
        transientIndex++;
        if (transientIndex &gt;= transientCount) {
            transientIndex = -1;
        }
    }
    int childIndex = customOrder ? getChildDrawingOrder(childrenCount, i) : i;
    final View child = (preorderedList == null)
            ? children[childIndex] : preorderedList.get(childIndex);
    if ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || child.getAnimation() != null) {
        more |= drawChild(canvas, child, drawingTime);
    }
}

      ....... 

      ....... 

      ....... 
  }
</code></pre><p>ViewGroup 在dispatchDraw()函数中对它的每一个孩子调用drawChild()，再看看drawChild()方法</p>
<pre><code>protected boolean drawChild(Canvas canvas, View child, long drawingTime) {
    return child.draw(canvas, this, drawingTime);
}
</code></pre><p>调用的child的draw方法 在draw()方法中，会调用computeScroll();</p>
<pre><code> private void smoothScrollBy(int dx, int dy) {
    mScroller.startScroll(getScrollX(), 0, dx, 0, 500);
    invalidate();
}

@Override
public void computeScroll() {
    if (mScroller.computeScrollOffset()) {
        scrollTo(mScroller.getCurrX(), mScroller.getCurrY());
        postInvalidate();
    }
}
</code></pre><p>Scroller 的startScroll方法只是保存了一些参数，单靠startScroll是无法发生滑动的，关键在于invalidate方法，导致重绘，重绘的时候，View的draw方法会调用computeScroll，computeScroll是空方法，我们自己来实现，比如在computeScroll中调用scrollTo方法就可以使得View产生滑动效果，然后再调用postInvalidate方法来进行第二次重绘，如此反复，直到整个滑动过程结束 参见《Android开发艺术探索》第三章 至于mScroller.computeScrollOffset()的方法：</p>
<pre><code>public boolean computeScrollOffset() {
    if (mFinished) {
        return false;
    }

    int timePassed = (int)(AnimationUtils.currentAnimationTimeMillis() - mStartTime);

    if (timePassed &lt; mDuration) {
        switch (mMode) {
        case SCROLL_MODE:
            final float x = mInterpolator.getInterpolation(timePassed * mDurationReciprocal);
            mCurrX = mStartX + Math.round(x * mDeltaX);
            mCurrY = mStartY + Math.round(x * mDeltaY);
            break;
        case FLING_MODE:
            final float t = (float) timePassed / mDuration;
            final int index = (int) (NB_SAMPLES * t);
            float distanceCoef = 1.f;
            float velocityCoef = 0.f;
            if (index &lt; NB_SAMPLES) {
                final float t_inf = (float) index / NB_SAMPLES;
                final float t_sup = (float) (index + 1) / NB_SAMPLES;
                final float d_inf = SPLINE_POSITION[index];
                final float d_sup = SPLINE_POSITION[index + 1];
                velocityCoef = (d_sup - d_inf) / (t_sup - t_inf);
                distanceCoef = d_inf + (t - t_inf) * velocityCoef;
            }

            mCurrVelocity = velocityCoef * mDistance / mDuration * 1000.0f;

            mCurrX = mStartX + Math.round(distanceCoef * (mFinalX - mStartX));
            // Pin to mMinX &lt;= mCurrX &lt;= mMaxX
            mCurrX = Math.min(mCurrX, mMaxX);
            mCurrX = Math.max(mCurrX, mMinX);

            mCurrY = mStartY + Math.round(distanceCoef * (mFinalY - mStartY));
            // Pin to mMinY &lt;= mCurrY &lt;= mMaxY
            mCurrY = Math.min(mCurrY, mMaxY);
            mCurrY = Math.max(mCurrY, mMinY);

            if (mCurrX == mFinalX &amp;&amp; mCurrY == mFinalY) {
                mFinished = true;
            }

            break;
        }
    }
    else {
        mCurrX = mFinalX;
        mCurrY = mFinalY;
        mFinished = true;
    }
    return true;
}
</code></pre><p>该方法的功能是随着时间的流逝，计算当前的scrollX和scrollY的值，相当于差之器的概念，根据时间流逝的百分比来计算，返回true，表示滑动未技术，返回false表示滑动结束</p>
<p>Scroller原理概括：Scroller本身并不能实现滑动，它需要配合View的computeScroll的方法才能完成弹性滑动的效果，它不断的让View重绘，而每一次重绘距滑动起始时间会有一个时间间隔，通过这个时间间隔，Scroller可以得到View当前的滑动位置，这样，View每次重绘都会导致View进行小幅度的移动，而多次的小幅度的移动就形成了弹性滑动。Scroller的设计很精妙，整个过程中，他对View没有丝毫的引用，甚至在它内部连计时器都没有。</p>
<p>参考 <a href="http://item.jd.com/11760209.html" target="_blank" rel="external">《Android开发艺术探索》</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/21/androidCodeAnsys/" itemprop="url">
                  《Android系统源代码情景分析》学习笔记1 Activity 组件的启动过程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-21T17:35:11+08:00" content="2016-05-21">
              2016-05-21
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/源码分析/" itemprop="url" rel="index">
                    <span itemprop="name">源码分析</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="《Android系统源代码情景分析》学习笔记1-Activity-组件的启动过程"><a href="#《Android系统源代码情景分析》学习笔记1-Activity-组件的启动过程" class="headerlink" title="《Android系统源代码情景分析》学习笔记1 Activity 组件的启动过程"></a>《Android系统源代码情景分析》学习笔记1 Activity 组件的启动过程</h3><blockquote>
<p>Activity 组件的启动过程</p>
</blockquote>
<p>MainActivity的android:process 属性设置为 “mainprocess”, Activity是通过Launcher组件来启动的，Launcher组件通过 Activity 管理服务ActivityManagerService来启动Activity ，ActivityManagerService在启动MainActivity组件时，就会发现系统中并不存在一个“mainprocess”进程，这是它就会先创建这个应用程序的进程，然后再讲MainActivity的组件启动起来；</p>
<p>由于MainActivity、Launcher、ActivityManagerService三者分别运行在不同的进程中，因此MainActivity的启动过程就涉及到了三个进程，这三个进程是通过Binder进程间通信机制来完成MainActivity组件的启动过程的。</p>
<p>Launcher组件启动MainActivity组件的过程如下：</p>
<p>（1）Launcher组件向ActivityManagerService发送一个启动MainActivity组件的进程间通信请求；</p>
<p>（2）ActivityManagerService首先将要启动的MainActivity的组件信息保存下来，然后再向launcher组件发送一个进入终止状态的进程间通信请求；</p>
<p>（3）Launcher组件进入终止状态后，就会向ActivityManagerService发送一个已进入终止状态的进程间通信请求，以便于ActivityManagerService继续执行启动MainActivity组件的操作；</p>
<p>（4）ActivityManagerService发现用来运行MainActivity组件的应用程序进程不存在，因此，它就会先启动一个新的应用程序进程；</p>
<p>（5）新的应用程序进程启动完成后，就会向ActivityManagerService发送一个启动完成的进程间通信，以便于ActivityManagerService继续执行启动MainActivity组件的操作；</p>
<p>（6）ActivityManagerService将保存下来的MainActivity的组件信息发送给刚刚为MainActivity创建的进程，以便于它将MainActivity组件启动起来。</p>
<p>这个过程共细分为35个步骤，下面进行详解：</p>
<pre><code>boolean startActivitySafely(View v, Intent intent, Object tag) {
    boolean success = false;
    try {
        success = startActivity(v, intent, tag);
    } catch (ActivityNotFoundException e) {
        Toast.makeText(this, R.string.activity_not_found, Toast.LENGTH_SHORT).show();
        Log.e(TAG, &quot;Unable to launch. tag=&quot; + tag + &quot; intent=&quot; + intent, e);
    }
         return success;
}
</code></pre><p>（1）当我们点击应用程序的快捷图标的时候，Launcher组件的成员函数startActivitySafely就会被调用来启动这个应用程序的根Activity，其中，要启动的信息包含在参数intent中。</p>
<p>那Launcher组件是如何获取这些信息的呢：系统启动的时候，会启动一个Package管理服务，PackageManagerService，并通过它来安装系统中的应用程序，PackageManagerService在安装一个应用程序的时候，会对它的AndroidManifest.xml文件进行解析，从而得到它里面的组件信息。系统启动完成之后，就会将Launcher组件启动起来，Launcher在启动的过程中，会想PackageManagerService查询有所Action名称=“Intent.ACTION_MAIN”并且Category=”Intent.CATEGORY_LAUNCHER”的Activity组件，最后为每一个Activity组件创建一个快捷图标，并将他们的信息与快捷图标关联起来。</p>
<pre><code>public void startActivityForResult(Intent intent, int requestCode, @Nullable Bundle options) {
 if (mParent == null) {
    Instrumentation.ActivityResult ar = mInstrumentation.execStartActivity(
    this, mMainThread.getApplicationThread(), mToken, this,ntent, requestCode, options);
    if (ar != null) {
    mMainThread.sendActivityResult(
    mToken, mEmbeddedID, requestCode, ar.getResultCode(),ar.getResultData());
 }
...
</code></pre><p>（2）Instrumentation:用来监控应用程序和系统之间的交互操作，因此调用Instrumentation的execStartActivity来代为执行Activity的组件操作，以便它可以监控这个交互过程。</p>
<p>execStartActivity()的几个参数： </p>
<p>mMainThread：类型为ActivityThead，用来描述一个应用程序进程，系统每当启动一个应用程序的时候，都会在这个应用程序里面加载一个ActivityThead类实例，这个实例保存在该进程中启动的Activity组件的父类Activity的成员变量mMainThread中。而ActivityThead的getApplicationThread()方法，用来获取它内部的一个类型为ApplicationThread的Binder本地对象。由于Launcher是Activity的子类，通过mMainThread.getApplicationThread()将Launcher所运行在的进程ActivityThead实例传递给mInstrumentation的方法execStartActivity()以便于可以将它传递给ActivityManagerService，这样ActivityManagerService接下来就可以通知Launcher组件进入Paused状态了；</p>
<p>mToken：类型为IBinder，是一个Binder的代理对象，指向了一个ActivityManagerService中一个类型为ActivityRecord的Binder本地对象。每个启动的Activity组件在ActivityManagerService中都有一个对应的ActivityRecord对象，用来维护对应的Activity组件的运行状态以及信息。将mToken传递给ActivityManagerService，以便于ActivityManagerService获取Launcher组件的详细信息；</p>
<pre><code>public ActivityResult execStartActivity(Context who, IBinder contextThread, 
IBinder token, Activity target,Intent intent, int requestCode, Bundle options) {
...

try {
    intent.migrateExtraStreamToClipData();
    intent.prepareToLeaveProcess();
     int result = ActivityManagerNative.getDefault().startActivity(whoThread,who.getBasePackageName(), intent,intent.resolveTypeIfNeeded(who.getContentResolver()),token, target != null ? target.mEmbeddedID : null,requestCode, 0, null, options);
    checkStartActivityResult(result, intent);
    } catch (RemoteException e) {
    }
    return null;
}
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/21/retrofit2/" itemprop="url">
                  retrofit2 源码分析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-21T17:27:43+08:00" content="2016-05-21">
              2016-05-21
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/源码分析/" itemprop="url" rel="index">
                    <span itemprop="name">源码分析</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Retrofit2-0-源码分析"><a href="#Retrofit2-0-源码分析" class="headerlink" title="Retrofit2.0 源码分析"></a>Retrofit2.0 源码分析</h3><p>这篇文章是学习了鸿洋大神(<a href="http://my.csdn.net/lmj623565791" target="_blank" rel="external">CSND</a>)的高水平作品<a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650820049&amp;idx=1&amp;sn=a9cf9bb280dd3364c4ee624f35586330&amp;scene=23&amp;srcid=050518A2ZfjQazoPnlq6VFu7#rd" target="_blank" rel="external">Retrofit2 完全解析</a>后自己整理了一部分。</p>
<blockquote>
<p>Retrofit 接口实现实例：</p>
</blockquote>
<pre><code>compile &apos;com.squareup.retrofit2:retrofit:2.0.2&apos;
</code></pre><p>实现方式：</p>
<pre><code>public interface IUserBiz
{
    @GET(&quot;users&quot;)
    Call&lt;List&lt;User&gt;&gt; getUsers();
}
</code></pre><p>通过Retrofit完成上述请求：</p>
<pre><code>Retrofit retrofit = new Retrofit.Builder()
    .baseUrl(&quot;http://192.168.31.242:8080/springmvc_users/user/&quot;)
    .addConverterFactory(GsonConverterFactory.create())
    .build();
    IUserBiz userBiz = retrofit.create(IUserBiz.class);
    Call&lt;List&lt;User&gt;&gt; call = userBiz.getUsers();
    call.enqueue(new Callback&lt;List&lt;User&gt;&gt;()
    {
        @Override
        public void onResponse(Call&lt;List&lt;User&gt;&gt; call, Response&lt;List&lt;User&gt;&gt; response)
        {
            Log.e(TAG, &quot;normalGet:&quot; + response.body() + &quot;&quot;);
        }

        @Override
        public void onFailure(Call&lt;List&lt;User&gt;&gt; call, Throwable t)
        {

        }
    });
</code></pre><p> 实现原理：动态代理：</p>
<p> Java动态代理的实现：</p>
<pre><code>  public interface ITest {

    @GET(&quot;/HEHE&quot;)
    public void add(int a, int b);

}

public static void main(String[] args) {

    ITest iTest = (ITest) Proxy.newProxyInstance(ITest.class.getClassLoader(), new Class&lt;?&gt;[]{ITest.class}, new InvocationHandler() {
        @Override
        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {

            Integer a = (Integer) args[0];
            Integer b = (Integer) args[1];
            System.out.println(&quot;方法名: &quot; + method.getName());
            System.out.println(&quot;参数: &quot; + a + &quot; , &quot; + b);



            GET get = method.getAnnotation(GET.class);
            System.out.println(&quot;注解:&quot; + get.value());

            return null;
        }
    });

    iTest.add(3,5);
    }
</code></pre><p>  可以看到，当调用接口的任何方法时：都会调用InvocationHandler#invoke方法，这个方法可以拿到传入的参数和注解等，Retrofit也是如此，看Retrofit源码：</p>
<pre><code>  public &lt;T&gt; T create(final Class&lt;T&gt; service) {
Utils.validateServiceInterface(service);
if (validateEagerly) {
  eagerlyValidateMethods(service);
}
return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] { service },
    new InvocationHandler() {
      private final Platform platform = Platform.get();

      @Override public Object invoke(Object proxy, Method method, Object... args)
          throws Throwable {
        // If the method is a method from Object then defer to normal invocation.
        if (method.getDeclaringClass() == Object.class) {
          return method.invoke(this, args);
        }
        if (platform.isDefaultMethod(method)) {
          return platform.invokeDefaultMethod(method, service, proxy, args);
        }
        ServiceMethod serviceMethod = loadServiceMethod(method);
        OkHttpCall okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args);
        return serviceMethod.callAdapter.adapt(okHttpCall);
      }
    });
    }
</code></pre><p> Retrofit的整体实现流程</p>
<p> 通过构造者模式进行构建Retrofit对象，</p>
<pre><code> public Builder() {
  this(Platform.get());
}

 public Retrofit build() {
  if (baseUrl == null) {
    throw new IllegalStateException(&quot;Base URL required.&quot;);
  }

  okhttp3.Call.Factory callFactory = this.callFactory;
  if (callFactory == null) {
    callFactory = new OkHttpClient();
  }

  Executor callbackExecutor = this.callbackExecutor;
  if (callbackExecutor == null) {
    callbackExecutor = platform.defaultCallbackExecutor();
  }

  // Make a defensive copy of the adapters and add the default Call adapter.
  List&lt;CallAdapter.Factory&gt; adapterFactories = new ArrayList&lt;&gt;(this.adapterFactories);
  adapterFactories.add(platform.defaultCallAdapterFactory(callbackExecutor));

  // Make a defensive copy of the converters.
  List&lt;Converter.Factory&gt; converterFactories = new ArrayList&lt;&gt;(this.converterFactories);

  return new Retrofit(callFactory, baseUrl, converterFactories, adapterFactories,
      callbackExecutor, validateEagerly);
}
</code></pre><ul>
<li>baseUrl必须指定，这个理所当然</li>
<li>如果不着急设置callFactory，则默认直接new OkHttpClient() ,可见如果需要对OkHttpClient进行详细设置，需要构建好以后传入</li>
<li>callbackExecutor 用来将回调传递到UI线程，这里设计的比较巧妙，利用platform对象对平台进行判断，判断主要是利用Class.forName(“ “)进行查找，如果是Android平台，会自定义一个Executor对象，并利用Looper.getMainLooper() 实例化一个handler对象，在Executor通过handler.post(Runnable),将回调传递到UI线程</li>
<li>然后是adapterFactories，这里可以传入RxJavaCallAdapterFactory，使用RxJava和Retrofit相结合</li>
<li>最后是 Converter.Factory，用于转化数据，例如将返回的reponseBody转化为对象</li>
</ul>
<p>具体Call的构建流程</p>
<pre><code>return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] { service },
    new InvocationHandler() {
      private final Platform platform = Platform.get();

      @Override public Object invoke(Object proxy, Method method, Object... args)
          throws Throwable {
        // If the method is a method from Object then defer to normal invocation.
        if (method.getDeclaringClass() == Object.class) {
          return method.invoke(this, args);
        }
        if (platform.isDefaultMethod(method)) {
          return platform.invokeDefaultMethod(method, service, proxy, args);
        }
        ServiceMethod serviceMethod = loadServiceMethod(method);
        OkHttpCall okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args);
        return serviceMethod.callAdapter.adapt(okHttpCall);
      }
    });
</code></pre><p> 主要就是三行代码：</p>
<pre><code>ServiceMethod serviceMethod = loadServiceMethod(method);
</code></pre><p>将我们的method包装成为ServiceMethod</p>
<pre><code>OkHttpCall okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args);
</code></pre><p>通过ServiceMethod和方法的参数构造retrofit2.OkHttpCall对象</p>
<pre><code>return serviceMethod.callAdapter.adapt(okHttpCall);
</code></pre><p>通过serviceMethod.callAdapter.adapt()方法，将OkHttpCall进行代理包装；</p>
<p>逐一介绍：</p>
<p>ServiceMethod包含了将method转化为Call的所有信息</p>
<pre><code>ServiceMethod loadServiceMethod(Method method) {
ServiceMethod result;
synchronized (serviceMethodCache) {
  result = serviceMethodCache.get(method);
  if (result == null) {
    result = new ServiceMethod.Builder(this, method).build();
    serviceMethodCache.put(method, result);
  }
}
return result; 
}

public ServiceMethod build() {
  callAdapter = createCallAdapter();
  responseType = callAdapter.responseType();
  if (responseType == Response.class || responseType == okhttp3.Response.class) {
    throw methodError(&quot;&apos;&quot;
        + Utils.getRawType(responseType).getName()
        + &quot;&apos; is not a valid response body type. Did you mean ResponseBody?&quot;);
  }
  responseConverter = createResponseConverter();

  for (Annotation annotation : methodAnnotations) {
    parseMethodAnnotation(annotation);
  }

  if (httpMethod == null) {
    throw methodError(&quot;HTTP method annotation is required (e.g., @GET, @POST, etc.).&quot;);
  }

  if (!hasBody) {
    if (isMultipart) {
      throw methodError(
          &quot;Multipart can only be specified on HTTP methods with request body (e.g., @POST).&quot;);
    }
    if (isFormEncoded) {
      throw methodError(&quot;FormUrlEncoded can only be specified on HTTP methods with &quot;
          + &quot;request body (e.g., @POST).&quot;);
    }
  }

  int parameterCount = parameterAnnotationsArray.length;
  parameterHandlers = new ParameterHandler&lt;?&gt;[parameterCount];
  for (int p = 0; p &lt; parameterCount; p++) {
    Type parameterType = parameterTypes[p];
    if (Utils.hasUnresolvableType(parameterType)) {
      throw parameterError(p, &quot;Parameter type must not include a type variable or wildcard: %s&quot;,
          parameterType);
    }

    Annotation[] parameterAnnotations = parameterAnnotationsArray[p];
    if (parameterAnnotations == null) {
      throw parameterError(p, &quot;No Retrofit annotation found.&quot;);
    }

    parameterHandlers[p] = parseParameter(p, parameterType, parameterAnnotations);
  }

  if (relativeUrl == null &amp;&amp; !gotUrl) {
    throw methodError(&quot;Missing either @%s URL or @Url parameter.&quot;, httpMethod);
  }
  if (!isFormEncoded &amp;&amp; !isMultipart &amp;&amp; !hasBody &amp;&amp; gotBody) {
    throw methodError(&quot;Non-body HTTP method cannot contain @Body.&quot;);
  }
  if (isFormEncoded &amp;&amp; !gotField) {
    throw methodError(&quot;Form-encoded method must contain at least one @Field.&quot;);
  }
  if (isMultipart &amp;&amp; !gotPart) {
    throw methodError(&quot;Multipart method must contain at least one @Part.&quot;);
  }

  return new ServiceMethod&lt;&gt;(this);
}
</code></pre><p>首先：</p>
<pre><code>callAdapter = createCallAdapter();
</code></pre><p> 最终拿到的是在retrofit build()里面 adapterFactories时添加的 即为：new ExecutorCallbackCall&lt;&gt;(callbackExecutor, call)，该ExecutorCallbackCall唯一做的事情就是将原本call的回调转发至UI线程。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/21/list/" itemprop="url">
                  ArrayList 和 LinkedList
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-21T17:15:42+08:00" content="2016-05-21">
              2016-05-21
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/数据结构与算法/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构与算法</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="ArrayList-和-LinkedList"><a href="#ArrayList-和-LinkedList" class="headerlink" title="ArrayList 和 LinkedList"></a>ArrayList 和 LinkedList</h3><ul>
<li><p>ArrayList set() 和 get()花费常数时间，但是插入新的项和删除现有的项，平均花费O(N)时间</p>
</li>
<li><p>LinkedList 但是插入新的项和删除现有的项花费常数时间，但是set() 和 get()花费平均花费O(N)时间（因为LinkedList在内存中的存储不是连续的，需要进行搜索）</p>
</li>
<li><p>对于任何Conllection的实现类（无论是ArrayList还是LinkedList），搜索方法contains()以及remove()都会花费平均花费O(N)时间</p>
<p>例子：删除一个List<integer>中的偶数</integer></p>
<p>方法1：</p>
<p>  public static void removeEvensVer1(List<integer> lst) {</integer></p>
<pre><code>int i = 0;
while(i &lt; lst.size()){
    if(lst.get(i) % 2 == 0){
        lst.remove(i);
    } else {
        i++;
    }
}
</code></pre><p>  }</p>
<p>评价：该方法的效率不高，因为：对于ArrayList因为remove()的效率不高，所以花费的是二次的时间，对于LinkedList，get()方法和remove()方法的效率都不高。</p>
<p>方法2：</p>
<p>  public static void removeEvensVer2(List<integer> lst){</integer></p>
<pre><code>for(Integer x : lst){
    if(x % 2 == 0){
        lst.remove(x);
    }
}
</code></pre><p>  }</p>
</li>
</ul>
<p>评价：该程序将产生一个异常，ConcurrentModificationException，因为当一项被删除的时候，由增强for循环使用的迭代器是非法的。</p>
<p>方法3：</p>
<pre><code>public static void removeEvensVar3(List&lt;Integer&gt; lst){
    Iterator&lt;Integer&gt; itr = lst.iterator();

    while(itr.hasNext()){
        if(itr.next() % 2 == 0){
            itr.remove();
        }
    }
}
</code></pre><p>评价：对于LinkedList的迭代器的remove()方法，对该迭代器的remove()方法的调用花费常数时间，因为该迭代器位于被删除的节点（或其附近），因此对于LinkedList，整个程序花费线性时间，而不是二次时间，但是对于ArrayList，即使迭代器位于被删除节点上或其附近，其remove的方法仍然是昂贵的，因为该节点删除后，其他的节点需要移动，所以ArrayList仍然会花费二次时间。</p>
<p>参考《数据结构与算法分析Java语言描述》</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/21/buildMyBlog/" itemprop="url">
                  这个博客是如何搭建的
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-21T16:42:14+08:00" content="2016-05-21">
              2016-05-21
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/教程/" itemprop="url" rel="index">
                    <span itemprop="name">教程</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><ul>
<li>GitHub</li>
<li>Hexo</li>
<li>Next</li>
</ul>
<h3 id="1-GitHub-Pages"><a href="#1-GitHub-Pages" class="headerlink" title="1 GitHub Pages"></a>1 GitHub Pages</h3><p>GitHub Pages提供了公共静态页面搭建托管服务器，不需要购买云服务即可搭建个人博客，当然，前提是首先得拥有<a href="https://github.com/" target="_blank" rel="external">GitHub账号</a>，如：我的GitHub账号用户名为：wzqhbkjdx。</p>
<blockquote>
<p>进入<a href="https://pages.github.com/" target="_blank" rel="external">GitHub Pages</a>，按引导完成相关操作即可，然后即可在浏览器点击打开<a href="http://wzqhbkjdx.github.io/" target="_blank" rel="external">http://wzqhbkjdx.github.io/</a></p>
</blockquote>
<h3 id="2-在个人的PC或Mac上安装Hexo博客框架"><a href="#2-在个人的PC或Mac上安装Hexo博客框架" class="headerlink" title="2 在个人的PC或Mac上安装Hexo博客框架"></a>2 在个人的PC或Mac上安装Hexo博客框架</h3><blockquote>
<p>安装Hexo之前需要安装Git 和 Node.js。 如：安装Node.js  在终端输入如下命令（需要Homebrew）</p>
</blockquote>
<pre><code>brew install node
</code></pre><blockquote>
<p>安装Hexo参考文档：<a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="external">中文文档</a> / <a href="https://hexo.io/docs/" target="_blank" rel="external">英文文档</a></p>
</blockquote>
<p>在配置GitHub Pages的时候，我们在本地新建了博客目录（如我的目录为myblog），并在myblog目录下从GitHub仓库clone了wzqhbkjdx.github.io目录。如下：</p>
<pre><code>myblog bym$ ls
wzqhbkjdx.github.io
</code></pre><blockquote>
<p>初始化Hexo </p>
</blockquote>
<pre><code>myblog bym$ hexo init wzqhbkjdx.github.io/
myblog bym$ cd wzqhbkjdx.github.io/
myblog bym$ npm install -g hexo
</code></pre><blockquote>
<p>执行完上述命令后，输入如下命令查看hexo版本</p>
</blockquote>
<pre><code>hexo v
</code></pre><p>如果遇见如下错误：</p>
<pre><code>{ [Error: Cannot find module &apos;./build/default/DTraceProviderBindings&apos;] code: &apos;MODULE_NOT_FOUND&apos; }
{ [Error: Cannot find module &apos;./build/Debug/DTraceProviderBindings&apos;] code: &apos;MODULE_NOT_FOUND&apos; }
</code></pre><p>原因是因为：由于天朝网络问题，没全部下载完。缺少 dtrace-provider 这个 module（可检查 node_modules 目录）。<a href="https://www.loveyunti.com/" target="_blank" rel="external">科学上网</a>后以下方案解决：</p>
<p>解决方案：依次执行如下命令：</p>
<pre><code>1. npm uninstall hexo //卸载hexo
2. npm install -g hexo --no-optional --save //重新安装
3. cd  wzqhbkjdx.github.io/，rm db.json，执行 npm install ，重新安装 package.json 中配置的依赖库(node_modules)；
4. hexo clean
5. hexo generate //重新编译整个博客网站
</code></pre><p>至此问题解决，Hexo博客框架已在本机搭建完成，下面是测试、连接、配置、写博客等工作啦。</p>
<p>上面问题的解决可以<a href="http://col.dog/2015/11/12/hello-world/" target="_blank" rel="external">参考这里</a></p>
<h3 id="3-测试并解决一些问题"><a href="#3-测试并解决一些问题" class="headerlink" title="3 测试并解决一些问题"></a>3 测试并解决一些问题</h3><pre><code>wzqhbkjdx.github.io bym$ hexo server
INFO  Start processing
INFO  Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.
</code></pre><p>按照提示在浏览器中访问<a href="http://localhost:4000/应该可以看到Hexo预设好的页面了" target="_blank" rel="external">http://localhost:4000/应该可以看到Hexo预设好的页面了</a></p>
<p>如果遇到问题可以<a href="https://segmentfault.com/a/1190000003088603" target="_blank" rel="external">参考这里</a></p>
<h3 id="4-与GitHub连接"><a href="#4-与GitHub连接" class="headerlink" title="4 与GitHub连接"></a>4 与GitHub连接</h3><pre><code>cd wzqhbkjdx.github.io/
wzqhbkjdx.github.io bym$ ls -l
total 152
-rw-r--r--@  1 bym   staff   1625  5 21 15:19 _config.yml
-rw-r--r--   1 bym   staff  61699  5 21 16:30 db.json
-rw-r--r--   1 bym   staff     12  5 21 11:47 index.html
drwxr-xr-x  13 bym   staff    442  5 21 13:00 node_modules
-rw-r--r--   1 root  staff    484  5 21 12:56 package.json
drwxr-xr-x  13 bym   staff    442  5 21 15:19 public
drwxr-xr-x   5 bym   staff    170  5 21 14:26 scaffolds
drwxr-xr-x   7 bym   staff    238  5 21 15:17 source
drwxr-xr-x   4 bym   staff    136  5 21 14:38 themes
wzqhbkjdx.github.io bym$ vim _config.yml
</code></pre><p>上边目录中各个子目录以及文件的功能介绍<a href="https://wingjay.com/2015/12/07/%E5%A6%82%E4%BD%95%E5%9C%A8%E4%B8%80%E5%A4%A9%E4%B9%8B%E5%86%85%E6%90%AD%E5%BB%BA%E4%BB%A5%E4%BD%A0%E8%87%AA%E5%B7%B1%E5%90%8D%E5%AD%97%E4%B8%BA%E5%9F%9F%E5%90%8D%E7%9A%84%E5%BE%88cool%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/" target="_blank" rel="external">参考这里</a></p>
<p>翻到最下面，做如下更改：(ps：注意冒号后的空格)</p>
<pre><code>deploy:
type: git
  repository: https://github.com/wzqhbkjdx/wzqhbkjdx.github.io.git
  branch: master
</code></pre><p> 退出vim执行</p>
<pre><code>hexo deploy
</code></pre><p> 此时遇到错误，因为还没有github这个type，所以需要执行如下命令：</p>
<pre><code>npm install hexo-deployer-git --save
</code></pre><p> 然后再：</p>
<pre><code>hexo deploy
</code></pre><p> 输入GitHub的账号和密码即可，问题解决<a href="https://github.com/hexojs/hexo/issues/1154" target="_blank" rel="external">参考这里</a></p>
<p> 然后在浏览器中访问：<a href="http://wzqhbkjdx.github.io/" target="_blank" rel="external">http://wzqhbkjdx.github.io/</a>就可以看到自己的博客了</p>
<h3 id="5-先发一篇博客再说"><a href="#5-先发一篇博客再说" class="headerlink" title="5 先发一篇博客再说"></a>5 先发一篇博客再说</h3><p> 配置的差不多一定已经急不可耐了吧，所以先发一篇博客再说：</p>
<pre><code> wzqhbkjdx.github.io bym$ hexo new buildMyBlog
INFO  Created: ~/Documents/myblog/wzqhbkjdx.github.io/source/_posts/buildMyBlog.md
</code></pre><p>然后编辑buildMyBlog.md，写入你的博客内容，关于MarkDown文本编辑格式可以<a href="https://www.zybuluo.com/mdeditor" target="_blank" rel="external">参考这里</a></p>
<p>然后同上，执行如下命令并输入GitHub账号和密码push到GitHub上即可</p>
<pre><code>hexo g
hexo deploy
</code></pre><h3 id="6-主题配置"><a href="#6-主题配置" class="headerlink" title="6 主题配置"></a>6 主题配置</h3><p>这里选用的Next主题，参考<a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="external">官方文档</a>即可进行详细的配置</p>
<h3 id="7-其他"><a href="#7-其他" class="headerlink" title="7 其他"></a>7 其他</h3><p>这个博客目前只到能用的地步，还不足够cool，所以想要更多，可以参考下列本文参考的文章</p>
<p><a href="http://ibruce.info/2013/11/22/hexo-your-blog/?utm_source=tuicool" target="_blank" rel="external">hexo你的博客</a></p>
<p><a href="http://col.dog/2015/11/12/hello-world/" target="_blank" rel="external">基于 Hexo 和 GitHub Pages 搭建博客</a></p>
<p><a href="https://wingjay.com/2015/12/07/%E5%A6%82%E4%BD%95%E5%9C%A8%E4%B8%80%E5%A4%A9%E4%B9%8B%E5%86%85%E6%90%AD%E5%BB%BA%E4%BB%A5%E4%BD%A0%E8%87%AA%E5%B7%B1%E5%90%8D%E5%AD%97%E4%B8%BA%E5%9F%9F%E5%90%8D%E7%9A%84%E5%BE%88cool%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/" target="_blank" rel="external">如何在一天之内搭建以你自己名字为域名又具备cool属性的个人博客</a></p>
<p><a href="https://segmentfault.com/a/1190000003088603" target="_blank" rel="external">最新版HEXO配置，HEXO+Github，搭建自己的博客</a></p>
<p><a href="https://nodejs.org/en/" target="_blank" rel="external">Node.js</a></p>
<p><a href="https://github.com/hexojs/hexo/issues/1055" target="_blank" rel="external">hexo shows error message</a></p>
<p><a href="http://www.selfrebuild.net/2015/06/24/Github-Hexo-Next%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E5%AE%9A%E5%88%B6/" target="_blank" rel="external">Hexo博客优化 - Next主题个性化定制</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/21/singleton/" itemprop="url">
                  singleton
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-21T14:06:08+08:00" content="2016-05-21">
              2016-05-21
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>单例模式</p>
<p>要求：</p>
<p>（1）构造函数不对外开放，一般为private</p>
<p>（2）通过一个静态方法或者枚举返回单例类对象</p>
<p>（3）确保单例类对象有且只有一个，尤其是在多线程的环境下</p>
<p>（4）确保单例类对象在反序列化时不会重新构建对象</p>
<p>单例模式的几种实现方式：</p>
<p>（1）饿汉式：</p>
<pre><code>public class Singleton {
    private Singleton() {
    }

    private static Singleton sInstance = new Singleton();

    public static SIngleton getInstance() {
        return sInstance;
    }

}
</code></pre><p>点评：饿汉式每次初始化的时候，都会创建对象，占用空间和资源。</p>
<p>（2）懒汉式：</p>
<pre><code>public class Singleton {
    private Singleton() {
    }
    private static Singleton sInstance;

    public static synchronized Singleton getInstance() {
        if(sInstance == null) {
            sInstance = new Singleton();
        }
        return sInstance;
    }
}
</code></pre><p>点评：懒汉式在调用getInstance()方法的时候才会初始化，但是每次调用getInstance()方法，都会进行同步，造成不必要的同步开销，所以这种模式一般也不建议使用。</p>
<p>（3）DCL(Double Check Lock)模式</p>
<pre><code>public class Singleton {
    private Singleton() {
    }
    private static Singleton sInstance;

    public static Singleton getInstance() {
        if(sInstance == null) {
            synchronized(Singleton.class) {
                if(sInstance == null) {
                    sInstance = new Singleton();
                }
            }
        }
        return sInstance;
    }
}
</code></pre><p>评价：DCL模式在getInstance()方法里进行了两次判断，第一次判断主要是为了避免不必要的同步，即sInstance为空的时候，才执行同步块中的内容，第二次判断判断sInstance是不是为空。不过由于sInstance = new Singleton();这句并不是原子操作，最终会被编译为多条指令执行，所以在多线程情况下可能回到之DCL模式失效，所以需要将sInstance定义改为：</p>
<pre><code>private static volatile Singleton sInstance;
</code></pre><p>(4)静态内部类单例模式：</p>
<pre><code>public class Singleton {
    private Singleton() {
    }
    public static Singleton getInstance() {
        return SingletonHolder.sInstance;
    }

    priate static class SingletonHolder {
        private static fianl Singleton sInstance = new Singleton();
    }
}
</code></pre><p>评价：由于内部类在内部类加载的时候才会被初始化，即在调用getInstance()方法的时候，内部类才会被初始化，所以这种方式不仅能够保证线程安全，也能保证单例对象的唯一性，同时延迟了单例的实例化，这种方式比较推荐。</p>
<p>（5）枚举单例模式：</p>
<pre><code>public enum Singleton {
    INSTANCE;
    public void doSomething() {
        System.out.println(&quot;do sth.&quot;);
    }
}
</code></pre><p>评价：（1）—–（4）几种方式，在一种情况下会出现重新创建对象的情况，那就是反序列化的时候，如果要杜绝单例对象被反序列化，那么必须在上述（1）—–（4）方式中加入如下方法：</p>
<pre><code>private Object readResolve() throws ObjectStreamException {
    return sInstance;
}
</code></pre><p>但是枚举就不会出现类似的问题，即使反序列化它也不会重新生成新的实例</p>
<p>参考 <a href="https://item.jd.com/11793928.html" target="_blank" rel="external">《Android源码设计模式》</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/avatar.jpg"
               alt="ADwangyang" />
          <p class="site-author-name" itemprop="name">ADwangyang</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/">
              <span class="site-state-item-count">8</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ADwangyang</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  



  
  
  

  

  

</body>
</html>
