<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="风车老家">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="风车老家">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="风车老家">
<meta name="twitter:description">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"always"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> 风车老家 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">风车老家</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/13/view/" itemprop="url">
                  View 的工作原理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-13T17:16:58+08:00" content="2016-06-13">
              2016-06-13
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/源码分析/" itemprop="url" rel="index">
                    <span itemprop="name">源码分析</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="ViewRoot-amp-DocerView"><a href="#ViewRoot-amp-DocerView" class="headerlink" title="ViewRoot &amp; DocerView"></a>ViewRoot &amp; DocerView</h3><p>ViewRoot对应于 ViewRootImpl类，是连接WindowManager和DecorView的纽带，View的三大流程（measure layout draw）都是通过ViewRoot来完成的，在ActivityThread中，当Activit被创建完毕后，会将DecorView添加到Window中，创建ViewRootImpl,并将ViewRootImpl对象和DecorView建立联系</p>
<p>View的绘制是从ViewRoot的performTraversals方法开始的，进过measure layout draw，将View绘制出来。</p>
<p>measure 确定View的宽和高</p>
<p>layout 确定在父容器中的位置</p>
<p>draw负责将View绘制在屏幕上</p>
<p>performMeasure——&gt;measure——&gt;onMeasure(在该方法中完成对所有子元素的measure过程) getMeasureWidth getMeasureHeight</p>
<p>performLayout 同理 getTop getBottom getLeft getRight</p>
<p>performDraw</p>
<h3 id="MeasureSpec"><a href="#MeasureSpec" class="headerlink" title="MeasureSpec"></a>MeasureSpec</h3><p>View的测量规格</p>
<p>MeasureSpec在很大程度上决定了View的尺寸规格，在测量的过程中，系统会将View的LayoutParam根据父容器所施加的规则转换成对应的MeasureSpec,然后再根据这个MeasureSpec来测量View的宽和高</p>
<p>MeasureSpec 代表32位int值，高2位代表SpecMode 低30位代表SpecSize，</p>
<p>SpecMode </p>
<p>UNSPECIFIED 系统内部使用</p>
<p>EXACTLY match_parent 有具体宽和高的</p>
<p>AT_MOST wrap_content</p>
<p>DecorView：的MeasureSpec尺寸由窗口的尺寸和其自身的LayoutParams来共同决定</p>
<p>普通View：    的MeasureSpec，由父容器的MeasureSpec和其自身的LayoutParams共同确定</p>
<h3 id="View的工作流程"><a href="#View的工作流程" class="headerlink" title="View的工作流程"></a>View的工作流程</h3><p>measure</p>
<pre><code>protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    setMeasuredDimension(
    getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),
    getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec)
    );
}

public static int getDefaultSize(int size, int measureSpec) {
    int result = size;
    int specMode = MeasureSpec.getMode(measureSpec);
    int specSize = MeasureSpec.getSize(measureSpec);

    switch (specMode) {
    case MeasureSpec.UNSPECIFIED:
        result = size;
        break;
    case MeasureSpec.AT_MOST:
    case MeasureSpec.EXACTLY:
        result = specSize;
        break;
    }
    return result;
}
</code></pre><p>得出结论：直接继承View的自定义控件，需要重写onMeasure方法，如果该控件的宽或者高有wrap_content属性时，需要我们手动设定大小，否则就相当于match_parent</p>
<p>ViewGroup的measure过程：除了完成自身的measure过程，还会去遍历调用其各个子元素的measure方法，各个子元素再递归去执行这个过程。</p>
<p>ViewGroup是抽象类，没有onMeasure方法，提供了measureChildren方法：</p>
<pre><code>protected void measureChildren(int widthMeasureSpec, int heightMeasureSpec) {
    final int size = mChildrenCount;
    final View[] children = mChildren;
    for (int i = 0; i &lt; size; ++i) {
        final View child = children[i];
        if ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) {
            measureChild(child, widthMeasureSpec, heightMeasureSpec);
        }
    }
}
</code></pre><p>layout</p>
<p>draw</p>
<p>LinearLayout 的measure过程</p>
<pre><code>protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    if (mOrientation == VERTICAL) {
        measureVertical(widthMeasureSpec, heightMeasureSpec);
    } else {
        measureHorizontal(widthMeasureSpec, heightMeasureSpec);
    }
}
</code></pre><p>在Activity中获取View的宽和高</p>
<p>由于Activity的生命周期方法和View的measure过程不同步，通过getMeasureWidth/Heigth在onCreate onStrart onResume中均无法正确获得View 的宽高信息。解决该问题的方法：</p>
<ul>
<li>复写Activity的onWindowFocusChanged方法</li>
</ul>
<p>onWindowFocusChanged在窗口得到或者失去焦点的时候都会调用，如果频繁的进行onResume和onPause，那么onWindowFocusChanged会被频繁的调用。</p>
<pre><code>@Override
public void onWindowFocusChanged(boolean hasFocus) {
    super.onWindowFocusChanged(hasFocus);
    if(hasFocus) {
        int hight = iv_picture.getMeasuredHeight();
        int width = iv_picture.getMeasuredWidth();
    }
}
</code></pre><ul>
<li>view.post(runnable)</li>
</ul>
<p>通过post将runnable投递到消息队列的尾部，然后等待Looper调用此runnable的时候，View已经初始化好了。</p>
<pre><code>@Override
protected void onStart() {
    super.onStart();
    iv_picture.post(new Runnable() {
        @Override
        public void run() {
            int hight = iv_picture.getMeasuredHeight();
            int width = iv_picture.getMeasuredWidth();
        }
    });
}
</code></pre><ul>
<li>使用ViewTreeObserver</li>
</ul>
<p>当View树的状态发生改变或者View树内部的View可见性发生改变时，onGLoalLayout方法将会被回调。</p>
<pre><code>@Override
protected void onStart() {
    super.onStart();

    ViewTreeObserver observer = iv_picture.getViewTreeObserver();
    observer.addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {
        @Override
        public void onGlobalLayout() {
            iv_picture.getViewTreeObserver().removeOnGlobalLayoutListener(this);
            int hight = iv_picture.getMeasuredHeight();
            int width = iv_picture.getMeasuredWidth();
        }
    });

}
</code></pre><h2 id="Layout过程"><a href="#Layout过程" class="headerlink" title="Layout过程"></a>Layout过程</h2><p>ViewGroup用来确定子元素的位置，当ViewGroup的位置确定后，在它的onLayout方法中，会遍历所有子元素并调用其的layout方法，在子元素的layout方法中，onLayout又会被调用。</p>
<pre><code>public void layout(int l, int t, int r, int b) {
    if ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != 0) {
        onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec);
        mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;
    }

    int oldL = mLeft;
    int oldT = mTop;
    int oldB = mBottom;
    int oldR = mRight;

    boolean changed = isLayoutModeOptical(mParent) ?
            setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);

    if (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) {
        onLayout(changed, l, t, r, b);
        mPrivateFlags &amp;= ~PFLAG_LAYOUT_REQUIRED;

        ListenerInfo li = mListenerInfo;
        if (li != null &amp;&amp; li.mOnLayoutChangeListeners != null) {
            ArrayList&lt;OnLayoutChangeListener&gt; listenersCopy =
                    (ArrayList&lt;OnLayoutChangeListener&gt;)li.mOnLayoutChangeListeners.clone();
            int numListeners = listenersCopy.size();
            for (int i = 0; i &lt; numListeners; ++i) {
                listenersCopy.get(i).onLayoutChange(this, l, t, r, b, oldL, oldT, oldR, oldB);
            }
        }
    }

    mPrivateFlags &amp;= ~PFLAG_FORCE_LAYOUT;
    mPrivateFlags3 |= PFLAG3_IS_LAID_OUT;
}
</code></pre><p>layout的过程概述：首先通过setFrame方法来设定View的四个顶点的位置，接着调用onLayout方法，用于父容器确定子元素的位置。</p>
<p>LinearLayout的onLayout方法：</p>
<pre><code>@Override
protected void onLayout(boolean changed, int l, int t, int r, int b) {
    if (mOrientation == VERTICAL) {
        layoutVertical(l, t, r, b);
    } else {
        layoutHorizontal(l, t, r, b);
    }
}

void layoutVertical(int left, int top, int right, int bottom) {
    final int paddingLeft = mPaddingLeft;

    int childTop;
    int childLeft;

    // Where right end of child should go
    final int width = right - left;
    int childRight = width - mPaddingRight;

    // Space available for child
    int childSpace = width - paddingLeft - mPaddingRight;

    final int count = getVirtualChildCount();

    final int majorGravity = mGravity &amp; Gravity.VERTICAL_GRAVITY_MASK;
    final int minorGravity = mGravity &amp; Gravity.RELATIVE_HORIZONTAL_GRAVITY_MASK;

    switch (majorGravity) {
       case Gravity.BOTTOM:
           // mTotalLength contains the padding already
           childTop = mPaddingTop + bottom - top - mTotalLength;
           break;

           // mTotalLength contains the padding already
       case Gravity.CENTER_VERTICAL:
           childTop = mPaddingTop + (bottom - top - mTotalLength) / 2;
           break;

       case Gravity.TOP:
       default:
           childTop = mPaddingTop;
           break;
    }

    for (int i = 0; i &lt; count; i++) {
        final View child = getVirtualChildAt(i);
        if (child == null) {
            childTop += measureNullChild(i);
        } else if (child.getVisibility() != GONE) {
            final int childWidth = child.getMeasuredWidth();
            final int childHeight = child.getMeasuredHeight();

            final LinearLayout.LayoutParams lp =
                    (LinearLayout.LayoutParams) child.getLayoutParams();

            int gravity = lp.gravity;
            if (gravity &lt; 0) {
                gravity = minorGravity;
            }
            final int layoutDirection = getLayoutDirection();
            final int absoluteGravity = Gravity.getAbsoluteGravity(gravity, layoutDirection);
            switch (absoluteGravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) {
                case Gravity.CENTER_HORIZONTAL:
                    childLeft = paddingLeft + ((childSpace - childWidth) / 2)
                            + lp.leftMargin - lp.rightMargin;
                    break;

                case Gravity.RIGHT:
                    childLeft = childRight - childWidth - lp.rightMargin;
                    break;

                case Gravity.LEFT:
                default:
                    childLeft = paddingLeft + lp.leftMargin;
                    break;
            }

            if (hasDividerBeforeChildAt(i)) {
                childTop += mDividerHeight;
            }

            childTop += lp.topMargin;
            setChildFrame(child, childLeft, childTop + getLocationOffset(child),
                    childWidth, childHeight);
            childTop += childHeight + lp.bottomMargin + getNextLocationOffset(child);

            i += getChildrenSkipCount(child, i);
        }
    }
}
</code></pre><p>在上面的代码中，可以看到，layoutVertial方法会遍历所有子元素，并调用setChildFrame方法来为子元素指定对应的位置，其中childTop会逐渐增大，说明后面的子元素会被放在考下的位置。setChildFrame方法调用了子元素的layout方法。</p>
<p>那么：getMeasureWidth 和getMeasuerWidth的区别<br>一般情况下测量宽高和最终宽高是相等的，只是测量宽高形成与View的measure过程，最终宽高形成于View的layout过程。</p>
<h2 id="Draw过程"><a href="#Draw过程" class="headerlink" title="Draw过程"></a>Draw过程</h2><ul>
<li>background.draw(cavas) 绘制背景</li>
<li>onDraw 绘制自己</li>
<li>dispatchDraw 绘制children</li>
<li>onDrawScrollBars 绘制装饰</li>
</ul>
<p>以上全文是学习 <a href="http://item.jd.com/11760209.html" target="_blank" rel="external">《Android开发艺术探索》</a> 后的笔记</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/24/priorityqueue/" itemprop="url">
                  优先队列
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-24T16:16:43+08:00" content="2016-05-24">
              2016-05-24
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/数据结构与算法/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构与算法</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="数据结构与算法——优先队列-priority-queue"><a href="#数据结构与算法——优先队列-priority-queue" class="headerlink" title="数据结构与算法——优先队列(priority queue)"></a>数据结构与算法——优先队列(priority queue)</h3><p><img src="http://img1.imgtn.bdimg.com/it/u=2643490497,3065329328&amp;fm=21&amp;gp=0.jpg" alt="priority queue"></p>
<blockquote>
<p>优先队列的两种基本操作</p>
</blockquote>
<ul>
<li>insert(enqueue)</li>
<li>deleteMin(dequeue)</li>
</ul>
<blockquote>
<p>优先队列的实现——二叉堆(binary heap)</p>
</blockquote>
<ul>
<li>结构性</li>
<li>堆序性(heap-order property)：目的是快速找到最小的元素，所以讲最小元素放在根上，且所有的子树也都是堆结构，所以所有的节点都小于它的子节点。所以findMin的操作是常数时间</li>
</ul>
<p>完全二叉树： 除了底层都被完全填充的二叉树(底层从左到右依次填充，所以有可能没有完全填充)</p>
<p>一颗高为h的完全二叉树，有2^h到2^(h+1)个节点，即完全二叉树的高为O(logN)</p>
<p>完全二叉树用数组存储的规律：对于数组中任意位置i上的元素，它的左儿子位于2i处，右儿子位于(2i+1)处，父节点位于i/2(向下取整)处。遍历简单，运行快速。</p>
<p>优先队列完成insert和deleteMin两种操作的关键在于“上滤”和 “下滤”两种方法的实现</p>
<p>insert后，实现上滤操作</p>
<pre><code>public void insert(AnyType x) {

    //在插入之前先判断是否还有空间
    if(currentSize == array.length - 1) {

        enlargeArray(array.length * 2 + 1);

    }

    //上滤操作
    int hole = ++ currentSize;
    for(; hole &gt; 1 &amp;&amp; x.compareTo(array[hole/2]) &lt; 0 ; hole /=2) {
        array[hole] = array[hole / 2]; //没有使用swap(x,y)这种方式，这样交换的次数比较少
    }
    array[hole] = x;

}
</code></pre><p>deleteMin后实现下滤操作</p>
<pre><code>public AnyType deleteMin() {

    if(isEmpty()) {
//            throw new Exception();
    }

    AnyType minItem = findMin();
    array[1] = array[currentSize];
    currentSize--;
    percolateDown(1);

    return minItem;

}

private void percolateDown(int hole) {

    int child;
    //缓存要下虑的值
    AnyType tmp = array[hole];

    /**
     * 1. 找到hole的两个子节点中较小的一个child
     * 2. 比较child的值和tmp中的值大小
     * 3. child大于tmp：结束循环，tmp直接保存在hole中
     * 4. child小于tmp：将child的值保存到hole中，下一个hole = child
     * 5. 进行下一轮循环
     */

    for(; hole * 2 &lt; currentSize; hole = child) {

        //找到hole的左子节点
        child = hole * 2;
        //右子节点 &lt; 左子节点
        if(child &lt; currentSize &amp;&amp; array[child + 1].compareTo(array[child]) &lt; 0) {
            child ++;
        }

        //child 和 tmp比较大小
        if(array[child].compareTo(tmp) &lt; 0) {
            array[hole] = array[child];
        } else {
            break;
        }

    }

    array[hole] = tmp;

}
</code></pre><p><img src="http://www.zgxue.com/bloguploapic/20141116001225568.jpg" alt="priority queue"></p>
<p>堆结构的实现：</p>
<p>public class BinaryHeap<anytype extends="" comparable<?="" super="" anytype="">&gt; {</anytype></p>
<pre><code>private static final int DEFAULT_CAPACITY = 10;
private int currentSize;
private AnyType[] array;

public BinaryHeap() {
    this(DEFAULT_CAPACITY);
}

public BinaryHeap(int capacity) {
    currentSize = 0;
    array = (AnyType[]) new Comparable[capacity + 1];
}

public BinaryHeap(AnyType[] items) {

    currentSize = items.length;
    array = (AnyType[]) new Comparable[(currentSize + 2) * 11 / 10];

    int i = 1;
    for(AnyType item : items) {
        array[i++] = item;
    }

    buildHeap(); //建堆
}

/**
 * 建堆的过程：从完全二叉树的倒数第二层子树开始，对每个有子节点的节点执行下滤操作，
 * 确保每个节点小于自己的两个子节点即可
 */
private void buildHeap() {

    for(int i = currentSize / 2; i &gt; 0; i++) {
        percolateDown(i);
    }


}


public AnyType findMin() {

    if(isEmpty()) {
        return null;
    } else {
        return array[1];
    }

}

private boolean isEmpty() {

    return currentSize == 0;
}

private void enlargeArray(int size) {

    if(size &lt;= array.length) {
        return;
    } else {

        AnyType[] oldArray = array;
        array = (AnyType[]) new Comparable[size + 1];

        int i = 0;
        for(AnyType item : oldArray) {
            array[i++] = item;
        }
    }

}

/**
 * 插入时长：O(logN)
 * @param x
 */
public void insert(AnyType x) {

    //在插入之前先判断是否还有空间
    if(currentSize == array.length - 1) {

        enlargeArray(array.length * 2 + 1);

    }

    //上滤操作
    int hole = ++ currentSize;
    for(; hole &gt; 1 &amp;&amp; x.compareTo(array[hole/2]) &lt; 0 ; hole /=2) {
        array[hole] = array[hole / 2]; //没有使用swap(x,y)这种方式，这样交换的次数比较少
    }
    array[hole] = x;

}

public AnyType deleteMin() {

    if(isEmpty()) {
//            throw new Exception();
    }

    AnyType minItem = findMin();
    array[1] = array[currentSize];
    currentSize--;
    percolateDown(1);

    return minItem;


}

private void percolateDown(int hole) {

    int child;
    //缓存要下虑的值
    AnyType tmp = array[hole];

    /**
     * 1. 找到hole的两个子节点中较小的一个child
     * 2. 比较child的值和tmp中的值大小
     * 3. child大于tmp：结束循环，tmp直接保存在hole中
     * 4. child小于tmp：将child的值保存到hole中，下一个hole = child
     * 5. 进行下一轮循环
     */

    for(; hole * 2 &lt; currentSize; hole = child) {

        //找到hole的左子节点
        child = hole * 2;
        //右子节点 &lt; 左子节点
        if(child &lt; currentSize &amp;&amp; array[child + 1].compareTo(array[child]) &lt; 0) {
            child ++;
        }

        //child 和 tmp比较大小
        if(array[child].compareTo(tmp) &lt; 0) {
            array[hole] = array[child];
        } else {
            break;
        }


    }

    array[hole] = tmp;



}

}
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/24/vim/" itemprop="url">
                  vim基本操作
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-24T13:43:13+08:00" content="2016-05-24">
              2016-05-24
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/教程/" itemprop="url" rel="index">
                    <span itemprop="name">教程</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li>在某行按 A 添加文本，光标定位在该行的哪个字符不重要 a 在光标后插入文本</li>
<li>d w 从光标定位的字符删除到下一个单词的起始处 所以w键可以定位到下一个单词的起始处</li>
<li>d e 从光标定位的字符删除到该单词的末尾 e定位到本单词的末尾</li>
<li>d $ 从当前光标删除到行末 $定位到行尾</li>
<li>2 w 向后移动两个单词到单词的起始位置</li>
<li>3 e 向后移动三个单词，到单词的末尾</li>
<li>0 移动光标当行首</li>
<li>dd 删除当前行 xdd （x代表数字）删除x行</li>
<li>u撤销前一操作，U撤销整行的操作，Ctrl + r 恢复被撤销的操作</li>
<li>dd可以剪切 p粘贴</li>
<li>r 替换当前光标所在位置的字符</li>
<li>ce cw 改变一个单词并进入插入模式</li>
<li>Ctrl + g 显示当前行信息</li>
<li>G跳转到当前编辑文本的最后一行 gg跳转到当前文本的首行</li>
<li>行号 + G 跳转到该行</li>
<li>/ + 要搜索的内容 向后搜索</li>
<li>？ + 要搜索的内容 向前搜索</li>
<li>Ctrl + o 让光标回到之前的位置</li>
<li>Ctrl + i 与 Ctrl + o 相反</li>
<li>% 找到配对的{ [ (</li>
<li>:s/old/new/g 将光标当前行的第一个old字符串替换为new字符串</li>
<li>:%s/old/new/g  替换整个文本    :%s/old/new/gc  替换整个文本并对每一个替换进行提示</li>
<li>: + ! + 命令 + &lt;回车&gt; 在vim内执行shell命令 如: +  ! + ls</li>
<li>v 进入可视模式进行选取 选取好文本后，输入：可以看到vim底部出现：’&lt;,’&gt; 输入w TEST 可以将选取好的文件保存的TEST中</li>
<li>：r TEST 将TEST文件写入到当前文件中 : r ls 将ls命令显示的文件写入到当前文件中</li>
<li>o 在当前行下面插入一行 O 在当前行上方插入一行</li>
<li>R 连续替换多个字符</li>
<li>y 和 v结合进行复制 yw复制一个字符</li>
<li>:set ic 查找时忽略大小写 :set noic禁用大小写 只在一次查找中忽略大小写 /test\c test为要查找的单词</li>
<li>:set is 查找短语时显示部分匹配</li>
<li>:set hls 高亮显示</li>
<li>使用Ctrl + d 以及tab的自动补全功能</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/22/retrofit/" itemprop="url">
                  retrofit
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-22T14:43:19+08:00" content="2016-05-22">
              2016-05-22
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/源码分析/" itemprop="url" rel="index">
                    <span itemprop="name">源码分析</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="/images/retrofit2.png" alt="retrofit2"></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/22/JVM/" itemprop="url">
                  Java虚拟机概述（一）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-22T14:30:37+08:00" content="2016-05-22">
              2016-05-22
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Java虚拟机/" itemprop="url" rel="index">
                    <span itemprop="name">Java虚拟机</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="/images/JVM.png" alt="JVM"></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/21/handler/" itemprop="url">
                  Handler、Looper
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-21T17:46:00+08:00" content="2016-05-21">
              2016-05-21
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/源码分析/" itemprop="url" rel="index">
                    <span itemprop="name">源码分析</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Handler、Looper"><a href="#Handler、Looper" class="headerlink" title="Handler、Looper"></a>Handler、Looper</h3><p>学习了<a href="http://www.cnblogs.com/codingmyworld/archive/2011/09/12/2174255.html" target="_blank" rel="external">这篇文章</a>后整理所得</p>
<p>在线程中有一个Looper对象，它内部维护了一个消息队列，且一个线程只能有一个Looper对象</p>
<p>因为Looper的prepare()方法的核心就是将looper对象定义为ThreadLocal</p>
<p>使用Looper类创建Looper线程很简单：</p>
<pre><code>public class LooperThread extends Thread {
        @Override
        public void run() {
        // 将当前线程初始化为Looper线程
        Looper.prepare();

        // ...其他处理，如实例化handler

        // 开始循环处理消息队列
        Looper.loop();
        }
 }

private static void prepare(boolean quitAllowed) {
    if (sThreadLocal.get() != null) {
        throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);
    }
    sThreadLocal.set(new Looper(quitAllowed));
}

关于ThreadLocal
 Implements a thread-local storage, that is, a variable for which each thread has 
 its own value. All threads share the same {@code ThreadLocal} object, but each 
 sees a different value when accessing it, and changes made by one thread do 
 not affect the other threads.
</code></pre><p>Loop()方法，调用loop方法后，Looper线程就开始工作了，不断从自己的MessageQueue中取出队头的消息执行</p>
<pre><code>/**
 * Run the message queue in this thread. Be sure to call
 * {@link #quit()} to end the loop.
 */
public static void loop() {
    final Looper me = myLooper();
    if (me == null) {
        throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&apos;t called on this thread.&quot;);
    }
    final MessageQueue queue = me.mQueue;

    // Make sure the identity of this thread is that of the local process,
    // and keep track of what that identity token actually is.
    Binder.clearCallingIdentity();
    final long ident = Binder.clearCallingIdentity();

    for (;;) {
        Message msg = queue.next(); // might block
        if (msg == null) {
            // No message indicates that the message queue is quitting.
            return;
        }

        // This must be in a local variable, in case a UI event sets the logger
        Printer logging = me.mLogging;
        if (logging != null) {
            logging.println(&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot; + msg.target + &quot; &quot; +
                    msg.callback + &quot;: &quot; + msg.what);
        }

        msg.target.dispatchMessage(msg);

        if (logging != null) {
            logging.println(&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback);
        }

        // Make sure that during the course of dispatching the
        // identity of the thread wasn&apos;t corrupted.
        final long newIdent = Binder.clearCallingIdentity();
        if (ident != newIdent) {
            Log.wtf(TAG, &quot;Thread identity changed from 0x&quot;
                    + Long.toHexString(ident) + &quot; to 0x&quot;
                    + Long.toHexString(newIdent) + &quot; while dispatching to &quot;
                    + msg.target.getClass().getName() + &quot; &quot;
                    + msg.callback + &quot; what=&quot; + msg.what);
        }

        msg.recycleUnchecked();
    }
}
</code></pre><p>关于Loopper的总结</p>
<ul>
<li>每个线程有且最多只能有一个Looper对象，它是一个ThreadLocal</li>
<li>Looper内部有一个消息队列，loop()方法调用后线程开始不断从队列中取出消息执行 msg.target.dispatchMessage(msg); 交由Handler来执行</li>
</ul>
<p>###Handler</p>
<p>Handler向MessageQueue添加消息，处理消息，只处理自己发出的消息，Handler创建的时候会关联一个Looper，默认的构造方法会关联当前线程的Looper。</p>
<pre><code>A Handler allows you to send and process {@link Message} and Runnableobjects associated 
with a thread&apos;s {@link MessageQueue}.  Each Handler instance is associated with a single thread 
and that thread&apos;s message queue.  When you create a new Handler, it is bound to the thread / message queue of the thread that is creating it -- 
from that point on, it will deliver messages and runnables to that message queue and execute them as they come out of the message queue. There are two main uses for a Handler: (1) to schedule messages and runnables to be executed as some point in the future; and (2) to enqueue an action to be performed on a different thread than your own.

public class Handler {

    final MessageQueue mQueue; //关联的MessageQueue
        final Looper mLooper; //关联的Looper
        final Callback mCallback; //回调函数

        public Handler(Callback callback, boolean async) {
    if (FIND_POTENTIAL_LEAKS) {
        final Class&lt;? extends Handler&gt; klass = getClass();
        if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;
                (klass.getModifiers() &amp; Modifier.STATIC) == 0) {
            Log.w(TAG, &quot;The following Handler class should be static or leaks might occur: &quot; +
                klass.getCanonicalName());
        }
    }
    // 默认将关联当前线程的looper
    mLooper = Looper.myLooper();
    if (mLooper == null) {
        throw new RuntimeException(
            &quot;Can&apos;t create handler inside thread that has not called Looper.prepare()&quot;);
    }
    // 重要！！！直接把关联looper的MQ作为自己的MQ，因此它的消息将发送到关联looper的MQ上
    mQueue = mLooper.mQueue;
    mCallback = callback;
    mAsynchronous = async;
}

}
</code></pre><p>下面我们就可以为之前的类加入Handler</p>
<pre><code>public class LooperThread extends Thread {
private Handler handler1;
private Handler handler2;

@Override
public void run() {
    // 将当前线程初始化为Looper线程
    Looper.prepare();

    // 实例化两个handler
    handler1 = new Handler();
    handler2 = new Handler();

    // 开始循环处理消息队列
    Looper.loop();
}
}
//一个线程可以有多个Handler，但是只能有一个Looper！
</code></pre><p>有了handler之后，我们就可以使用 post(Runnable), postAtTime(Runnable, long), postDelayed(Runnable, long), sendEmptyMessage(int), sendMessage(Message), sendMessageAtTime(Message, long)和 sendMessageDelayed(Message, long)这些方法向MQ上发送消息了。光看这些API你可能会觉得handler能发两种消息，一种是Runnable对象，一种是message对象，这是直观的理解，但其实post发出的Runnable对象最后都被封装成message对象了</p>
<p>Handler处理消息</p>
<p>消息的处理是通过核心方法dispatchMessage(Message msg)与钩子方法handleMessage(Message msg)完成的</p>
<pre><code>// 处理消息，该方法由looper调用
public void dispatchMessage(Message msg) {
    if (msg.callback != null) {
        // 如果message设置了callback，即runnable消息，处理callback！
        handleCallback(msg);
    } else {
        // 如果handler本身设置了callback，则执行callback
        if (mCallback != null) {
             /* 这种方法允许让activity等来实现Handler.Callback接口，避免了自己编写handler重写handleMessage方法。见http://alex-yang-xiansoftware-com.iteye.com/blog/850865 */
            if (mCallback.handleMessage(msg)) {
                return;
            }
        }
        // 如果message没有callback，则调用handler的钩子方法handleMessage
        handleMessage(msg);
    }
}

// 处理runnable消息
private final void handleCallback(Message message) {
    message.callback.run();  //直接调用run方法！
}
// 由子类实现的钩子方法
public void handleMessage(Message msg) {
}
</code></pre><p>Handler可以在任意线程发送消息，这些消息会被添加到关联的MessageQueue上</p>
<p>Handler是在它关联的looper线程中处理消息的</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/21/viewDispatchEvent/" itemprop="url">
                  View的事件分发机制
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-21T17:41:31+08:00" content="2016-05-21">
              2016-05-21
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/源码分析/" itemprop="url" rel="index">
                    <span itemprop="name">源码分析</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="View的事件分发机制"><a href="#View的事件分发机制" class="headerlink" title="View的事件分发机制"></a>View的事件分发机制</h3><p>该机制是解决View滑动冲突的核心理论</p>
<p>所谓的事件分发机制就是对MotionEvent的事件分发</p>
<p>View的事件分发由三个很重要的方法共同完成：</p>
<pre><code>//Pass the touch screen motion event down to the target view, or this view if it is the target.
dispatchTouchEvent(MotionEvent e)

//Implement this method to intercept all touch screen motion events.  This allows you to watch events as they are dispatched to your children, and take ownership of the current gesture at any point.
onInterceptTouchEvent(MotionEvent e)


onTouchEvent(MotionEvent e)
</code></pre><p>ViewGroup -&gt; ViewGroup -&gt; View </p>
<p>View onTouchEvent() -&gt; VIewGroup onTouchEvent() -&gt; ViewGroup onTouchEvent()</p>
<p>Activity -&gt; Window -&gt; decor view(当前界面的底层容器，即setContentView方法所设置的View的父容器)通过Activity.getWindow().getDecorView() 可以获得</p>
<p>Activity 的 dispatchTouchEvent()方法</p>
<pre><code>public boolean dispatchTouchEvent(MotionEvent ev) {
    if (ev.getAction() == MotionEvent.ACTION_DOWN) {
        onUserInteraction();
    }
    //首先交给Activity所属的Window来进行事件分发，如果返回True，则整个事件结束，如果返回false，意味着事件没人处理，所有View的onTouchEvent 都返回了false，则Activity的onTouchEvent就会被调用
    if (getWindow().superDispatchTouchEvent(ev)) {
        return true;
    }
    return onTouchEvent(ev);
}
</code></pre><p>接下来看一下Window是如何将事件传递给ViewGroup的</p>
<p>Window是抽象类，它的superDispatchTouchEvent是个抽象方法，它的唯一实现类是PhoneWindow</p>
<pre><code>@Override
public boolean superDispatchTouchEvent(MotionEvent event) {
//直接传递给了DecorView
 return mDecor.superDispatchTouchEvent(event);
}
</code></pre><p>最终通过DecorView传递到Activity setContentView() 方法中的View里</p>
<p>通过下面方法可以得到Activity所设置的View </p>
<pre><code>((ViewGroup)getWindow().getDecorView().findViewById(android.R.id.content)).getChildAt(0);
</code></pre><p>下面看一下ViewGroup的dispatchTouchEvent()方法</p>
<pre><code>// Check for interception.
final boolean intercepted;
if (actionMasked == MotionEvent.ACTION_DOWN
        || mFirstTouchTarget != null) {
    final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0;
    if (!disallowIntercept) {
        intercepted = onInterceptTouchEvent(ev);
        ev.setAction(action); // restore action in case it was changed
    } else {
        intercepted = false;
    }
} else {
    // There are no touch targets and this action is not an initial down
    // so this view group continues to intercept touches.
    intercepted = true;
}
</code></pre><p>  从上面的代码可以看出：当事件类型为ACTION_DOWN或者mFristTouchTarget != null时（事件由子元素成功处理，mFirstTouchTarget被赋值并指向子元素，此时mFristTouchTarget不为空，即一旦ViewGroup拦截当前事件，则mFristTouchTarget即为空） ，ViewGroup会进一步去调用onInterceptTouchEvent方法来判断是否需要拦截当前事件。那么，当ACTION_MOVE ACTION_UP事件到来时，上述两个条件不成立，导致ViewGroup的onInterceptTouchEvent方法不会再被调用，同一序列中的其他事件都会默认交给ViewGroup来处理。</p>
<p>  特殊情况：标记位：FLAG_DISALLOW_INTERCEPT，通过requestDisallowInterceptTouchEvent方法来设置，一般用于子View中，该标记位一旦设置后，ViewGroup将无法拦截除了ACTION_DOWN以外的其他点击事件（因为ACTION_DOWN会重置FLAG_DISALLOW_INTERCEPT，导致子View中设置的这个标记位无效。）</p>
<pre><code> // Handle an initial down.
if (actionMasked == MotionEvent.ACTION_DOWN) {
    // Throw away all previous state when starting a new touch gesture.
    // The framework may have dropped the up or cancel event for the previous gesture
    // due to an app switch, ANR, or some other state change.
    cancelAndClearTouchTargets(ev);
    resetTouchState(); //在该方法中对FLAG_DISALLOW_INTERCEPT进行重置
}
</code></pre><p>  所以FLAG_DISALLOW_INTERCEPT标志位的作用就是让ViewGroup不再拦截事件，当然前提是ViewGroup不拦截ActionDown事件。</p>
<p>  可见：（1）onInterceptTouchEvent方法不是每次都会被调用的，如果想提前处理所有的点击事件，要选择dispatchTouchEvent方法；</p>
<p>  （2）FLAG_DISALLOW_INTERCEPT提供了解决滑动冲突的思路</p>
<p>  ViewGroup不拦截事件，事件向下分发，交给它的子View进行处理：</p>
<pre><code>final View[] children = mChildren;
      for (int i = childrenCount - 1; i &gt;= 0; i--) {
          final int childIndex = customOrder
                  ? getChildDrawingOrder(childrenCount, i) : i;
          final View child = (preorderedList == null)
                  ? children[childIndex] : preorderedList.get(childIndex);

          // If there is a view that has accessibility focus we want it
          // to get the event first and if not handled we will perform a
          // normal dispatch. We may do a double iteration but this is
          // safer given the timeframe.
          if (childWithAccessibilityFocus != null) {
              if (childWithAccessibilityFocus != child) {
                  continue;
              }
              childWithAccessibilityFocus = null;
              i = childrenCount - 1;
          }

          if (!canViewReceivePointerEvents(child)
                  || !isTransformedTouchPointInView(x, y, child, null)) {
              ev.setTargetAccessibilityFocus(false);
              continue;
          }

          newTouchTarget = getTouchTarget(child);
          if (newTouchTarget != null) {
              // Child is already receiving touch within its bounds.
              // Give it the new pointer in addition to the ones it is handling.
              newTouchTarget.pointerIdBits |= idBitsToAssign;
              break;
          }

          resetCancelNextUpFlag(child);
          if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {
              // Child wants to receive touch within its bounds.
              mLastTouchDownTime = ev.getDownTime();
              if (preorderedList != null) {
                  // childIndex points into presorted list, find original index
                  for (int j = 0; j &lt; childrenCount; j++) {
                      if (children[childIndex] == mChildren[j]) {
                          mLastTouchDownIndex = j;
                          break;
                      }
                  }
              } else {
                  mLastTouchDownIndex = childIndex;
              }
              mLastTouchDownX = ev.getX();
              mLastTouchDownY = ev.getY();
              newTouchTarget = addTouchTarget(child, idBitsToAssign);
              alreadyDispatchedToNewTouchTarget = true;
              break;
          }
</code></pre><p> 上述代码的分析：首先遍历ViewGroup的所有子元素，然后判断子元素是否能够接收点击事件（即子元素是否在播放动画以及点击事件的坐标是否落在子元素的区域内），如果某个子元素满足这个条件，事件就会传递给它来处理。如果遍历所有的子元素后，事件都没有得到处理（ViewGroup没有子元素，子元素在onTouchEvent中返回了false）</p>
<p> View对点击事件的处理：单独的View无法向下传递事件，只能自己处理 </p>
<pre><code> public boolean dispatchTouchEvent(MotionEvent event) {
    // If the event should be handled by accessibility focus first.
    if (event.isTargetAccessibilityFocus()) {
        // We don&apos;t have focus or no virtual descendant has it, do not handle the event.
        if (!isAccessibilityFocusedViewOrHost()) {
            return false;
        }
        // We have focus and got the event, then use normal event dispatch.
        event.setTargetAccessibilityFocus(false);
    }

    boolean result = false;

    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTouchEvent(event, 0);
    }

    final int actionMasked = event.getActionMasked();
    if (actionMasked == MotionEvent.ACTION_DOWN) {
        // Defensive cleanup for new gesture
        stopNestedScroll();
    }

    if (onFilterTouchEventForSecurity(event)) {
        //noinspection SimplifiableIfStatement
        ListenerInfo li = mListenerInfo;
        if (li != null &amp;&amp; li.mOnTouchListener != null
                &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED
                &amp;&amp; li.mOnTouchListener.onTouch(this, event)) {
            result = true;
        }

        if (!result &amp;&amp; onTouchEvent(event)) {
            result = true;
        }
    }

    if (!result &amp;&amp; mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onUnhandledEvent(event, 0);
    }

    // Clean up after nested scrolls if this is the end of a gesture;
    // also cancel it if we tried an ACTION_DOWN but we didn&apos;t want the rest
    // of the gesture.
    if (actionMasked == MotionEvent.ACTION_UP ||
            actionMasked == MotionEvent.ACTION_CANCEL ||
            (actionMasked == MotionEvent.ACTION_DOWN &amp;&amp; !result)) {
        stopNestedScroll();
    }

    return result;
}

public boolean onTouchEvent(MotionEvent event) {
    final float x = event.getX();
    final float y = event.getY();
    final int viewFlags = mViewFlags;
    final int action = event.getAction();

    if ((viewFlags &amp; ENABLED_MASK) == DISABLED) {
        if (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != 0) {
            setPressed(false);
        }
        // A disabled view that is clickable still consumes the touch
        // events, it just doesn&apos;t respond to them.
        return (((viewFlags &amp; CLICKABLE) == CLICKABLE
                || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)
                || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE);
    }

    if (mTouchDelegate != null) {
        if (mTouchDelegate.onTouchEvent(event)) {
            return true;
        }
    }

    if (((viewFlags &amp; CLICKABLE) == CLICKABLE ||
            (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) ||
            (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE) {
        switch (action) {
            case MotionEvent.ACTION_UP:
                boolean prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != 0;
                if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0 || prepressed) {
                    // take focus if we don&apos;t have it already and we should in
                    // touch mode.
                    boolean focusTaken = false;
                    if (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) {
                        focusTaken = requestFocus();
                    }

                    if (prepressed) {
                        // The button is being released before we actually
                        // showed it as pressed.  Make it show the pressed
                        // state now (before scheduling the click) to ensure
                        // the user sees it.
                        setPressed(true, x, y);
                   }

                    if (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) {
                        // This is a tap, so remove the longpress check
                        removeLongPressCallback();

                        // Only perform take click actions if we were in the pressed state
                        if (!focusTaken) {
                            // Use a Runnable and post this rather than calling
                            // performClick directly. This lets other visual state
                            // of the view update before click actions start.
                            if (mPerformClick == null) {
                                mPerformClick = new PerformClick();
                            }
                            if (!post(mPerformClick)) {
                                performClick();
                            }
                        }
                    }

                    if (mUnsetPressedState == null) {
                        mUnsetPressedState = new UnsetPressedState();
                    }

                    if (prepressed) {
                        postDelayed(mUnsetPressedState,
                                ViewConfiguration.getPressedStateDuration());
                    } else if (!post(mUnsetPressedState)) {
                        // If the post failed, unpress right now
                        mUnsetPressedState.run();
                    }

                    removeTapCallback();
                }
                mIgnoreNextUpEvent = false;
                break;

            case MotionEvent.ACTION_DOWN:
                mHasPerformedLongPress = false;

                if (performButtonActionOnTouchDown(event)) {
                    break;
                }

                // Walk up the hierarchy to determine if we&apos;re inside a scrolling container.
                boolean isInScrollingContainer = isInScrollingContainer();

                // For views inside a scrolling container, delay the pressed feedback for
                // a short period in case this is a scroll.
                if (isInScrollingContainer) {
                    mPrivateFlags |= PFLAG_PREPRESSED;
                    if (mPendingCheckForTap == null) {
                        mPendingCheckForTap = new CheckForTap();
                    }
                    mPendingCheckForTap.x = event.getX();
                    mPendingCheckForTap.y = event.getY();
                    postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());
                } else {
                    // Not inside a scrolling container, so show the feedback right away
                    setPressed(true, x, y);
                    checkForLongClick(0);
                }
                break;

            case MotionEvent.ACTION_CANCEL:
                setPressed(false);
                removeTapCallback();
                removeLongPressCallback();
                mInContextButtonPress = false;
                mHasPerformedLongPress = false;
                mIgnoreNextUpEvent = false;
                break;

            case MotionEvent.ACTION_MOVE:
                drawableHotspotChanged(x, y);

                // Be lenient about moving outside of buttons
                if (!pointInView(x, y, mTouchSlop)) {
                    // Outside button
                    removeTapCallback();
                    if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0) {
                        // Remove any future long press/tap checks
                        removeLongPressCallback();

                        setPressed(false);
                    }
                }
                break;
        }

        return true;
    }

    return false;
}
</code></pre><p>以上全文是学习 <a href="http://item.jd.com/11760209.html" target="_blank" rel="external">《Android开发艺术探索》</a> 后的笔记    </p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/21/scroller/" itemprop="url">
                  Scroller源码分析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-21T17:37:40+08:00" content="2016-05-21">
              2016-05-21
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/源码分析/" itemprop="url" rel="index">
                    <span itemprop="name">源码分析</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Scroller"><a href="#Scroller" class="headerlink" title="Scroller"></a>Scroller</h3><p>View类的方法是个空函数，实现自定义View的滑动就需要手动去复写该方法</p>
<pre><code>/** 
 * Called by a parent to request that a child update its values for mScrollX 
 * and mScrollY if necessary. This will typically be done if the child is 
 * animating a scroll using a {@link android.widget.Scroller Scroller} 
 * object. 
 */
public void computeScroll() 
{ 
}
</code></pre><p>那么：computeScroll()是怎样被调用的呢？看一下ViewGroup的源码</p>
<pre><code>@Override 
  protected void dispatchDraw(Canvas canvas) { 

      ....... 

      ....... 

      ....... 

      ....... 

     for (int i = 0; i &lt; childrenCount; i++) {
    while (transientIndex &gt;= 0 &amp;&amp; mTransientIndices.get(transientIndex) == i) {
        final View transientChild = mTransientViews.get(transientIndex);
        if ((transientChild.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE ||
                transientChild.getAnimation() != null) {
            more |= drawChild(canvas, transientChild, drawingTime);
        }
        transientIndex++;
        if (transientIndex &gt;= transientCount) {
            transientIndex = -1;
        }
    }
    int childIndex = customOrder ? getChildDrawingOrder(childrenCount, i) : i;
    final View child = (preorderedList == null)
            ? children[childIndex] : preorderedList.get(childIndex);
    if ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || child.getAnimation() != null) {
        more |= drawChild(canvas, child, drawingTime);
    }
}

      ....... 

      ....... 

      ....... 
  }
</code></pre><p>ViewGroup 在dispatchDraw()函数中对它的每一个孩子调用drawChild()，再看看drawChild()方法</p>
<pre><code>protected boolean drawChild(Canvas canvas, View child, long drawingTime) {
    return child.draw(canvas, this, drawingTime);
}
</code></pre><p>调用的child的draw方法 在draw()方法中，会调用computeScroll();</p>
<pre><code> private void smoothScrollBy(int dx, int dy) {
    mScroller.startScroll(getScrollX(), 0, dx, 0, 500);
    invalidate();
}

@Override
public void computeScroll() {
    if (mScroller.computeScrollOffset()) {
        scrollTo(mScroller.getCurrX(), mScroller.getCurrY());
        postInvalidate();
    }
}
</code></pre><p>Scroller 的startScroll方法只是保存了一些参数，单靠startScroll是无法发生滑动的，关键在于invalidate方法，导致重绘，重绘的时候，View的draw方法会调用computeScroll，computeScroll是空方法，我们自己来实现，比如在computeScroll中调用scrollTo方法就可以使得View产生滑动效果，然后再调用postInvalidate方法来进行第二次重绘，如此反复，直到整个滑动过程结束 参见《Android开发艺术探索》第三章 至于mScroller.computeScrollOffset()的方法：</p>
<pre><code>public boolean computeScrollOffset() {
    if (mFinished) {
        return false;
    }

    int timePassed = (int)(AnimationUtils.currentAnimationTimeMillis() - mStartTime);

    if (timePassed &lt; mDuration) {
        switch (mMode) {
        case SCROLL_MODE:
            final float x = mInterpolator.getInterpolation(timePassed * mDurationReciprocal);
            mCurrX = mStartX + Math.round(x * mDeltaX);
            mCurrY = mStartY + Math.round(x * mDeltaY);
            break;
        case FLING_MODE:
            final float t = (float) timePassed / mDuration;
            final int index = (int) (NB_SAMPLES * t);
            float distanceCoef = 1.f;
            float velocityCoef = 0.f;
            if (index &lt; NB_SAMPLES) {
                final float t_inf = (float) index / NB_SAMPLES;
                final float t_sup = (float) (index + 1) / NB_SAMPLES;
                final float d_inf = SPLINE_POSITION[index];
                final float d_sup = SPLINE_POSITION[index + 1];
                velocityCoef = (d_sup - d_inf) / (t_sup - t_inf);
                distanceCoef = d_inf + (t - t_inf) * velocityCoef;
            }

            mCurrVelocity = velocityCoef * mDistance / mDuration * 1000.0f;

            mCurrX = mStartX + Math.round(distanceCoef * (mFinalX - mStartX));
            // Pin to mMinX &lt;= mCurrX &lt;= mMaxX
            mCurrX = Math.min(mCurrX, mMaxX);
            mCurrX = Math.max(mCurrX, mMinX);

            mCurrY = mStartY + Math.round(distanceCoef * (mFinalY - mStartY));
            // Pin to mMinY &lt;= mCurrY &lt;= mMaxY
            mCurrY = Math.min(mCurrY, mMaxY);
            mCurrY = Math.max(mCurrY, mMinY);

            if (mCurrX == mFinalX &amp;&amp; mCurrY == mFinalY) {
                mFinished = true;
            }

            break;
        }
    }
    else {
        mCurrX = mFinalX;
        mCurrY = mFinalY;
        mFinished = true;
    }
    return true;
}
</code></pre><p>该方法的功能是随着时间的流逝，计算当前的scrollX和scrollY的值，相当于差之器的概念，根据时间流逝的百分比来计算，返回true，表示滑动未技术，返回false表示滑动结束</p>
<p>Scroller原理概括：Scroller本身并不能实现滑动，它需要配合View的computeScroll的方法才能完成弹性滑动的效果，它不断的让View重绘，而每一次重绘距滑动起始时间会有一个时间间隔，通过这个时间间隔，Scroller可以得到View当前的滑动位置，这样，View每次重绘都会导致View进行小幅度的移动，而多次的小幅度的移动就形成了弹性滑动。Scroller的设计很精妙，整个过程中，他对View没有丝毫的引用，甚至在它内部连计时器都没有。</p>
<p>参考 <a href="http://item.jd.com/11760209.html" target="_blank" rel="external">《Android开发艺术探索》</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/21/androidCodeAnsys/" itemprop="url">
                  《Android系统源代码情景分析》学习笔记1 Activity 组件的启动过程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-21T17:35:11+08:00" content="2016-05-21">
              2016-05-21
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/源码分析/" itemprop="url" rel="index">
                    <span itemprop="name">源码分析</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="《Android系统源代码情景分析》学习笔记1-Activity-组件的启动过程"><a href="#《Android系统源代码情景分析》学习笔记1-Activity-组件的启动过程" class="headerlink" title="《Android系统源代码情景分析》学习笔记1 Activity 组件的启动过程"></a>《Android系统源代码情景分析》学习笔记1 Activity 组件的启动过程</h3><blockquote>
<p>Activity 组件的启动过程</p>
</blockquote>
<p>MainActivity的android:process 属性设置为 “mainprocess”, Activity是通过Launcher组件来启动的，Launcher组件通过 Activity 管理服务ActivityManagerService来启动Activity ，ActivityManagerService在启动MainActivity组件时，就会发现系统中并不存在一个“mainprocess”进程，这是它就会先创建这个应用程序的进程，然后再讲MainActivity的组件启动起来；</p>
<p>由于MainActivity、Launcher、ActivityManagerService三者分别运行在不同的进程中，因此MainActivity的启动过程就涉及到了三个进程，这三个进程是通过Binder进程间通信机制来完成MainActivity组件的启动过程的。</p>
<p>Launcher组件启动MainActivity组件的过程如下：</p>
<p>（1）Launcher组件向ActivityManagerService发送一个启动MainActivity组件的进程间通信请求；</p>
<p>（2）ActivityManagerService首先将要启动的MainActivity的组件信息保存下来，然后再向launcher组件发送一个进入终止状态的进程间通信请求；</p>
<p>（3）Launcher组件进入终止状态后，就会向ActivityManagerService发送一个已进入终止状态的进程间通信请求，以便于ActivityManagerService继续执行启动MainActivity组件的操作；</p>
<p>（4）ActivityManagerService发现用来运行MainActivity组件的应用程序进程不存在，因此，它就会先启动一个新的应用程序进程；</p>
<p>（5）新的应用程序进程启动完成后，就会向ActivityManagerService发送一个启动完成的进程间通信，以便于ActivityManagerService继续执行启动MainActivity组件的操作；</p>
<p>（6）ActivityManagerService将保存下来的MainActivity的组件信息发送给刚刚为MainActivity创建的进程，以便于它将MainActivity组件启动起来。</p>
<p>这个过程共细分为35个步骤，下面进行详解：</p>
<pre><code>boolean startActivitySafely(View v, Intent intent, Object tag) {
    boolean success = false;
    try {
        success = startActivity(v, intent, tag);
    } catch (ActivityNotFoundException e) {
        Toast.makeText(this, R.string.activity_not_found, Toast.LENGTH_SHORT).show();
        Log.e(TAG, &quot;Unable to launch. tag=&quot; + tag + &quot; intent=&quot; + intent, e);
    }
         return success;
}
</code></pre><p>（1）当我们点击应用程序的快捷图标的时候，Launcher组件的成员函数startActivitySafely就会被调用来启动这个应用程序的根Activity，其中，要启动的信息包含在参数intent中。</p>
<p>那Launcher组件是如何获取这些信息的呢：系统启动的时候，会启动一个Package管理服务，PackageManagerService，并通过它来安装系统中的应用程序，PackageManagerService在安装一个应用程序的时候，会对它的AndroidManifest.xml文件进行解析，从而得到它里面的组件信息。系统启动完成之后，就会将Launcher组件启动起来，Launcher在启动的过程中，会想PackageManagerService查询有所Action名称=“Intent.ACTION_MAIN”并且Category=”Intent.CATEGORY_LAUNCHER”的Activity组件，最后为每一个Activity组件创建一个快捷图标，并将他们的信息与快捷图标关联起来。</p>
<pre><code>public void startActivityForResult(Intent intent, int requestCode, @Nullable Bundle options) {
 if (mParent == null) {
    Instrumentation.ActivityResult ar = mInstrumentation.execStartActivity(
    this, mMainThread.getApplicationThread(), mToken, this,ntent, requestCode, options);
    if (ar != null) {
    mMainThread.sendActivityResult(
    mToken, mEmbeddedID, requestCode, ar.getResultCode(),ar.getResultData());
 }
...
</code></pre><p>（2）Instrumentation:用来监控应用程序和系统之间的交互操作，因此调用Instrumentation的execStartActivity来代为执行Activity的组件操作，以便它可以监控这个交互过程。</p>
<p>execStartActivity()的几个参数： </p>
<p>mMainThread：类型为ActivityThead，用来描述一个应用程序进程，系统每当启动一个应用程序的时候，都会在这个应用程序里面加载一个ActivityThead类实例，这个实例保存在该进程中启动的Activity组件的父类Activity的成员变量mMainThread中。而ActivityThead的getApplicationThread()方法，用来获取它内部的一个类型为ApplicationThread的Binder本地对象。由于Launcher是Activity的子类，通过mMainThread.getApplicationThread()将Launcher所运行在的进程ActivityThead实例传递给mInstrumentation的方法execStartActivity()以便于可以将它传递给ActivityManagerService，这样ActivityManagerService接下来就可以通知Launcher组件进入Paused状态了；</p>
<p>mToken：类型为IBinder，是一个Binder的代理对象，指向了一个ActivityManagerService中一个类型为ActivityRecord的Binder本地对象。每个启动的Activity组件在ActivityManagerService中都有一个对应的ActivityRecord对象，用来维护对应的Activity组件的运行状态以及信息。将mToken传递给ActivityManagerService，以便于ActivityManagerService获取Launcher组件的详细信息；</p>
<pre><code>public ActivityResult execStartActivity(Context who, IBinder contextThread, 
IBinder token, Activity target,Intent intent, int requestCode, Bundle options) {
...

try {
    intent.migrateExtraStreamToClipData();
    intent.prepareToLeaveProcess();
     int result = ActivityManagerNative.getDefault().startActivity(whoThread,who.getBasePackageName(), intent,intent.resolveTypeIfNeeded(who.getContentResolver()),token, target != null ? target.mEmbeddedID : null,requestCode, 0, null, options);
    checkStartActivityResult(result, intent);
    } catch (RemoteException e) {
    }
    return null;
}
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/21/retrofit2/" itemprop="url">
                  retrofit2 源码分析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-21T17:27:43+08:00" content="2016-05-21">
              2016-05-21
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/源码分析/" itemprop="url" rel="index">
                    <span itemprop="name">源码分析</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Retrofit2-0-源码分析"><a href="#Retrofit2-0-源码分析" class="headerlink" title="Retrofit2.0 源码分析"></a>Retrofit2.0 源码分析</h3><p>这篇文章是学习了鸿洋大神(<a href="http://my.csdn.net/lmj623565791" target="_blank" rel="external">CSND</a>)的高水平作品<a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650820049&amp;idx=1&amp;sn=a9cf9bb280dd3364c4ee624f35586330&amp;scene=23&amp;srcid=050518A2ZfjQazoPnlq6VFu7#rd" target="_blank" rel="external">Retrofit2 完全解析</a>后自己整理了一部分。</p>
<blockquote>
<p>Retrofit 接口实现实例：</p>
</blockquote>
<pre><code>compile &apos;com.squareup.retrofit2:retrofit:2.0.2&apos;
</code></pre><p>实现方式：</p>
<pre><code>public interface IUserBiz
{
    @GET(&quot;users&quot;)
    Call&lt;List&lt;User&gt;&gt; getUsers();
}
</code></pre><p>通过Retrofit完成上述请求：</p>
<pre><code>Retrofit retrofit = new Retrofit.Builder()
    .baseUrl(&quot;http://192.168.31.242:8080/springmvc_users/user/&quot;)
    .addConverterFactory(GsonConverterFactory.create())
    .build();
    IUserBiz userBiz = retrofit.create(IUserBiz.class);
    Call&lt;List&lt;User&gt;&gt; call = userBiz.getUsers();
    call.enqueue(new Callback&lt;List&lt;User&gt;&gt;()
    {
        @Override
        public void onResponse(Call&lt;List&lt;User&gt;&gt; call, Response&lt;List&lt;User&gt;&gt; response)
        {
            Log.e(TAG, &quot;normalGet:&quot; + response.body() + &quot;&quot;);
        }

        @Override
        public void onFailure(Call&lt;List&lt;User&gt;&gt; call, Throwable t)
        {

        }
    });
</code></pre><p> 实现原理：动态代理：</p>
<p> Java动态代理的实现：</p>
<pre><code>  public interface ITest {

    @GET(&quot;/HEHE&quot;)
    public void add(int a, int b);

}

public static void main(String[] args) {

    ITest iTest = (ITest) Proxy.newProxyInstance(ITest.class.getClassLoader(), new Class&lt;?&gt;[]{ITest.class}, new InvocationHandler() {
        @Override
        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {

            Integer a = (Integer) args[0];
            Integer b = (Integer) args[1];
            System.out.println(&quot;方法名: &quot; + method.getName());
            System.out.println(&quot;参数: &quot; + a + &quot; , &quot; + b);



            GET get = method.getAnnotation(GET.class);
            System.out.println(&quot;注解:&quot; + get.value());

            return null;
        }
    });

    iTest.add(3,5);
    }
</code></pre><p>  可以看到，当调用接口的任何方法时：都会调用InvocationHandler#invoke方法，这个方法可以拿到传入的参数和注解等，Retrofit也是如此，看Retrofit源码：</p>
<pre><code>  public &lt;T&gt; T create(final Class&lt;T&gt; service) {
Utils.validateServiceInterface(service);
if (validateEagerly) {
  eagerlyValidateMethods(service);
}
return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] { service },
    new InvocationHandler() {
      private final Platform platform = Platform.get();

      @Override public Object invoke(Object proxy, Method method, Object... args)
          throws Throwable {
        // If the method is a method from Object then defer to normal invocation.
        if (method.getDeclaringClass() == Object.class) {
          return method.invoke(this, args);
        }
        if (platform.isDefaultMethod(method)) {
          return platform.invokeDefaultMethod(method, service, proxy, args);
        }
        ServiceMethod serviceMethod = loadServiceMethod(method);
        OkHttpCall okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args);
        return serviceMethod.callAdapter.adapt(okHttpCall);
      }
    });
    }
</code></pre><p> Retrofit的整体实现流程</p>
<p> 通过构造者模式进行构建Retrofit对象，</p>
<pre><code> public Builder() {
  this(Platform.get());
}

 public Retrofit build() {
  if (baseUrl == null) {
    throw new IllegalStateException(&quot;Base URL required.&quot;);
  }

  okhttp3.Call.Factory callFactory = this.callFactory;
  if (callFactory == null) {
    callFactory = new OkHttpClient();
  }

  Executor callbackExecutor = this.callbackExecutor;
  if (callbackExecutor == null) {
    callbackExecutor = platform.defaultCallbackExecutor();
  }

  // Make a defensive copy of the adapters and add the default Call adapter.
  List&lt;CallAdapter.Factory&gt; adapterFactories = new ArrayList&lt;&gt;(this.adapterFactories);
  adapterFactories.add(platform.defaultCallAdapterFactory(callbackExecutor));

  // Make a defensive copy of the converters.
  List&lt;Converter.Factory&gt; converterFactories = new ArrayList&lt;&gt;(this.converterFactories);

  return new Retrofit(callFactory, baseUrl, converterFactories, adapterFactories,
      callbackExecutor, validateEagerly);
}
</code></pre><ul>
<li>baseUrl必须指定，这个理所当然</li>
<li>如果不着急设置callFactory，则默认直接new OkHttpClient() ,可见如果需要对OkHttpClient进行详细设置，需要构建好以后传入</li>
<li>callbackExecutor 用来将回调传递到UI线程，这里设计的比较巧妙，利用platform对象对平台进行判断，判断主要是利用Class.forName(“ “)进行查找，如果是Android平台，会自定义一个Executor对象，并利用Looper.getMainLooper() 实例化一个handler对象，在Executor通过handler.post(Runnable),将回调传递到UI线程</li>
<li>然后是adapterFactories，这里可以传入RxJavaCallAdapterFactory，使用RxJava和Retrofit相结合</li>
<li>最后是 Converter.Factory，用于转化数据，例如将返回的reponseBody转化为对象</li>
</ul>
<p>具体Call的构建流程</p>
<pre><code>return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] { service },
    new InvocationHandler() {
      private final Platform platform = Platform.get();

      @Override public Object invoke(Object proxy, Method method, Object... args)
          throws Throwable {
        // If the method is a method from Object then defer to normal invocation.
        if (method.getDeclaringClass() == Object.class) {
          return method.invoke(this, args);
        }
        if (platform.isDefaultMethod(method)) {
          return platform.invokeDefaultMethod(method, service, proxy, args);
        }
        ServiceMethod serviceMethod = loadServiceMethod(method);
        OkHttpCall okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args);
        return serviceMethod.callAdapter.adapt(okHttpCall);
      }
    });
</code></pre><p> 主要就是三行代码：</p>
<pre><code>ServiceMethod serviceMethod = loadServiceMethod(method);
</code></pre><p>将我们的method包装成为ServiceMethod</p>
<pre><code>OkHttpCall okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args);
</code></pre><p>通过ServiceMethod和方法的参数构造retrofit2.OkHttpCall对象</p>
<pre><code>return serviceMethod.callAdapter.adapt(okHttpCall);
</code></pre><p>通过serviceMethod.callAdapter.adapt()方法，将OkHttpCall进行代理包装；</p>
<p>逐一介绍：</p>
<p>ServiceMethod包含了将method转化为Call的所有信息</p>
<pre><code>ServiceMethod loadServiceMethod(Method method) {
ServiceMethod result;
synchronized (serviceMethodCache) {
  result = serviceMethodCache.get(method);
  if (result == null) {
    result = new ServiceMethod.Builder(this, method).build();
    serviceMethodCache.put(method, result);
  }
}
return result; 
}

public ServiceMethod build() {
  callAdapter = createCallAdapter();
  responseType = callAdapter.responseType();
  if (responseType == Response.class || responseType == okhttp3.Response.class) {
    throw methodError(&quot;&apos;&quot;
        + Utils.getRawType(responseType).getName()
        + &quot;&apos; is not a valid response body type. Did you mean ResponseBody?&quot;);
  }
  responseConverter = createResponseConverter();

  for (Annotation annotation : methodAnnotations) {
    parseMethodAnnotation(annotation);
  }

  if (httpMethod == null) {
    throw methodError(&quot;HTTP method annotation is required (e.g., @GET, @POST, etc.).&quot;);
  }

  if (!hasBody) {
    if (isMultipart) {
      throw methodError(
          &quot;Multipart can only be specified on HTTP methods with request body (e.g., @POST).&quot;);
    }
    if (isFormEncoded) {
      throw methodError(&quot;FormUrlEncoded can only be specified on HTTP methods with &quot;
          + &quot;request body (e.g., @POST).&quot;);
    }
  }

  int parameterCount = parameterAnnotationsArray.length;
  parameterHandlers = new ParameterHandler&lt;?&gt;[parameterCount];
  for (int p = 0; p &lt; parameterCount; p++) {
    Type parameterType = parameterTypes[p];
    if (Utils.hasUnresolvableType(parameterType)) {
      throw parameterError(p, &quot;Parameter type must not include a type variable or wildcard: %s&quot;,
          parameterType);
    }

    Annotation[] parameterAnnotations = parameterAnnotationsArray[p];
    if (parameterAnnotations == null) {
      throw parameterError(p, &quot;No Retrofit annotation found.&quot;);
    }

    parameterHandlers[p] = parseParameter(p, parameterType, parameterAnnotations);
  }

  if (relativeUrl == null &amp;&amp; !gotUrl) {
    throw methodError(&quot;Missing either @%s URL or @Url parameter.&quot;, httpMethod);
  }
  if (!isFormEncoded &amp;&amp; !isMultipart &amp;&amp; !hasBody &amp;&amp; gotBody) {
    throw methodError(&quot;Non-body HTTP method cannot contain @Body.&quot;);
  }
  if (isFormEncoded &amp;&amp; !gotField) {
    throw methodError(&quot;Form-encoded method must contain at least one @Field.&quot;);
  }
  if (isMultipart &amp;&amp; !gotPart) {
    throw methodError(&quot;Multipart method must contain at least one @Part.&quot;);
  }

  return new ServiceMethod&lt;&gt;(this);
}
</code></pre><p>首先：</p>
<pre><code>callAdapter = createCallAdapter();
</code></pre><p> 最终拿到的是在retrofit build()里面 adapterFactories时添加的 即为：new ExecutorCallbackCall&lt;&gt;(callbackExecutor, call)，该ExecutorCallbackCall唯一做的事情就是将原本call的回调转发至UI线程。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/avatar.jpg"
               alt="ADwangyang" />
          <p class="site-author-name" itemprop="name">ADwangyang</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/">
              <span class="site-state-item-count">13</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">9</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ADwangyang</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  



  
  
  

  

  

</body>
</html>
