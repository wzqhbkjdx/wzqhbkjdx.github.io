<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="风车老家">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="风车老家">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="风车老家">
<meta name="twitter:description">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"always"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> 风车老家 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">风车老家</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/26/ECF/" itemprop="url">
                  异常控制流
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-26T07:51:20+08:00" content="2016-07-26">
              2016-07-26
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/计算机基础/" itemprop="url" rel="index">
                    <span itemprop="name">计算机基础</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>标签（空格分隔）： 计算机基础</p>
<hr>
<p>现代操作系统通过使控制流发生突变来对硬件中断信号，网络数据保存到磁盘，子进程终止。这些突变称为异常控制流（ECF），异常控制流发生在计算机系统的各个层次：硬件层面，操作系统，应用层等。</p>
<p>ECF是操作系统用来实现I/O，进程和虚拟存储器的基本机制。</p>
<p>应用程序通过使用一个叫做陷阱或者系统调用的ECF向操作系统请求服务。</p>
<p>操作系统为应用程序提供了强大的EOF机制，用来创建新进程，等待进程终止，通知其他进程系统中的异常事件，以及检测和响应这些事件。</p>
<p>ECF是计算机系统中实现并发的基本机制。</p>
<p>Java通过try catch以及throw语句来提供软件异常机制，这是一种非本地跳转，一种应用层的EOF，在C中是通过setjump和longjmp，理解这些低级函数将有助于理解高级软件的异常如何实现。</p>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><blockquote>
<p>异常是ECF的一种形式，它一部分由硬件实现，一部分由软件实现。</p>
</blockquote>
<p>异常就是控制流中的突变。</p>
<p>在处理器中，状态被编码为不同的位和信号，状态变化称为事件。在任何情况下，当处理器检测到有事件发生时，它就会通过一张叫做异常表的跳转表，进行一个间接过程调用，到异常处理程序。</p>
<p>系统中可能的每种异常的类型都分配了一个唯一的非负整数的异常号，其中的一些号码是由处理器的设计者分配的，如：除零，缺页，存储器访问违例，断点以及算数溢出，另一些号码是由操作系统内核的设计者分配的，如：系统调用以及来自外部I/O设备的信号。</p>
<p>在系统加电启动的时候，操作系统分配和初始化一张称为异常表的跳转表，使得条目k包含异常k的处理程序的地址。异常表的起始地址放在一个叫做异常表基址寄存器的特殊CPU寄存器里。</p>
<p>异常的类别：</p>
<p>中断，返回后执行下一条指令</p>
<p>陷阱或系统调用，返回后执行下一条指令</p>
<p>故障，返回到引起故障的指令 或 abort</p>
<p>终止，abort</p>
<p><strong>故障和终止</strong></p>
<p><code>除法错误：</code> 浮点异常。</p>
<p><code>一般保护故障：</code>一个进程引用了一个未定义的虚拟存储器区域，或者程序试图写一个只读的文本段，Linux不会试图恢复这类故障，这种故障被shell程序报告为：段错误。</p>
<p><code>缺页：</code>处理程序将磁盘上物理存储器响应的页面映射到虚拟存储器的一个页面，然后重新开始产生这条故障的指令。</p>
<p><code>机器检查：</code> 是在导致故障的指令执行中检测到致命的硬件错误时发生的。</p>
<p><strong>系统调用</strong></p>
<p>应用程序想要请求内核服务的时候可以使用，包括读文件，写文件或者创建一个新进程。</p>
<p>对于大多数系统调用 标准C库提供了一组包装函数。</p>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><blockquote>
<p>一个执行中的程序的实例，系统中每个程序都是运行在某个进程的上下文(context)中。<br>上下文是由程序正确运行所需的状态组成的，存放在存储器中的程序的代码和数据，它的栈，通用目的寄存器的内容，程序计数器，环境变量以及打开的文件的描述符的集合。</p>
</blockquote>
<p>进程提供给应用程序的关键抽象：</p>
<p><strong>一个独立的逻辑控制流</strong> 它提供一个假象，好像我们的程序独占地使用处理器。</p>
<p><strong>一个私有的地址空间</strong> 它提供一个假象，好像我们的程序独占的使用存储系统。</p>
<p>私有地址空间：</p>
<p>进程为每个程序提供它自己的私有地址空间。和这个空间中某个地址相关联的那个存储器（内存）字节是不能被其他进程读或写的，</p>
<pre><code>内核虚拟存储器（代码，数据，堆，栈）
用户栈（运行时创建）栈指针
共享库的存储器映射区
运行时堆（malloc创建）
读/写段（从可执行文件加载的）
只读段（从可执行文件加载的）
</code></pre><p><strong>用户模式和内核模式</strong></p>
<p>为了使操作系统内核提供一个无懈可击的进程抽象，处理器通过某个控制寄存器中的模式位（如ARM处理器中的cpsr寄存器）来限制一个应用可以执行的指令以及它可以访问的地址空间范围。</p>
<p>进程从用户模式变为内核模式的唯一方法是通过中断、故障或者陷入系统调用这样的异常。</p>
<p>Linux提供了一种/proc文件系统，允许用户模式进程访问内核数据结构的内容。</p>
<p>2.6版本的Linux内核引入了/sys文件系统，它输出关于系统总线和设备的额外的低层信息。</p>
<p><strong>上下文切换</strong></p>
<p>上下文切换是一种较高层形式的ECF(异常控制流)，操作系统使用上下文切换来实现多任务。</p>
<p>在进程执行的某些时刻，内核可以决定抢占当前进程，并重新开始一个先前被抢占的进程。这种决定叫做调度schedule，是由内核中称为调度器（scheduler）的代码处理的。</p>
<p>当内核代表用户执行系统调用的时候可能会发生上下文切换，比如系统调用因读取磁盘文件而阻塞，那么内核可以让当前进程休眠，切换到另一个进程。</p>
<p>中断也肯能引发上下文切换，如定时器中断。</p>
<h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><pre><code>getpid()
getppid()
</code></pre><p>进程的三种状态：</p>
<ul>
<li>运行</li>
<li>停止</li>
<li>终止：收到一个终止进程的信号；从主程序返回，exit()</li>
</ul>
<blockquote>
<p>fork() 父进程通过fork函数新建一个子进程，新创建的子进程几乎但是不完全与父进程相同，子进程得到与父进程用户级虚拟地址空间相同的但是独立的一份拷贝，包括：文本，数据，bss段，堆以及用户栈。同时子进程还获得与父进程任何打开文件描述符相同的拷贝，当父进程调动fork时，子进程可以读写父进程中打开的任何文件，父进程和子进程的PID不同。</p>
</blockquote>
<pre><code>pid_t waitpid() 等待子进程终止
</code></pre><p><strong>加载器工作流程概述</strong></p>
<blockquote>
<p>Unix系统中的每个程序都运行在一个进程上下文中，有自己的虚拟地址空间。当shell运行一个程序时，父shell进程通过fork函数生成一个子进程，它是父进程的一个复制品。然后子进程通过execve系统调用启动加载器（加载器是驻留在存储器中的一段操作系统代码）加载器删除子进程现有的虚拟存储器段，并创建一组新的代码、数据、堆和栈段。新的栈和堆段被初始化为0。通过将虚拟地址空间中的页映射到可执行文件的页大小的片(chunk)，新的代码和数据段被初始化为可执行文件的内容。最后，加载器跳转到_start地址，它最终会调用应用程序的main函数。除了一些头部信息，在加载的过程中，没有任何从磁盘到存储器的数据拷贝。直到CPU引用一个被映射的虚拟页才会进行拷贝，此时，操作系统用它的页调度机制自动将页面从磁盘传送到存储器。</p>
</blockquote>
<h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><blockquote>
<p>一种更高层的软件形式的异常</p>
</blockquote>
<pre><code>No    Name         Default Action       Description
 1     SIGHUP       terminate process    terminal line hangup
 2     SIGINT       terminate process    interrupt program
 3     SIGQUIT      create core image    quit program
 4     SIGILL       create core image    illegal instruction
 5     SIGTRAP      create core image    trace trap
 6     SIGABRT      create core image    abort program (formerly SIGIOT)
 7     SIGEMT       create core image    emulate instruction executed
 8     SIGFPE       create core image    floating-point exception
 9     SIGKILL      terminate process    kill program
 10    SIGBUS       create core image    bus error
 11    SIGSEGV      create core image    segmentation violation
 12    SIGSYS       create core image    non-existent system call invoked
 13    SIGPIPE      terminate process    write on a pipe with no reader
 14    SIGALRM      terminate process    real-time timer expired
 15    SIGTERM      terminate process    software termination signal
 16    SIGURG       discard signal       urgent condition present on
                                         socket
 17    SIGSTOP      stop process         stop (cannot be caught or
                                         ignored)
 18    SIGTSTP      stop process         stop signal generated from
                                         keyboard
 19    SIGCONT      discard signal       continue after stop
 20    SIGCHLD      discard signal       child status has changed
 21    SIGTTIN      stop process         background read attempted from
                                         control terminal
 22    SIGTTOU      stop process         background write attempted to
                                         control terminal
 23    SIGIO        discard signal       I/O is possible on a descriptor
                                         (see fcntl(2))
 24    SIGXCPU      terminate process    cpu time limit exceeded (see
                                         setrlimit(2))
 25    SIGXFSZ      terminate process    file size limit exceeded (see
                                         setrlimit(2))
 26    SIGVTALRM    terminate process    virtual time alarm (see
                                         setitimer(2))
 27    SIGPROF      terminate process    profiling timer alarm (see
                                         setitimer(2))
 28    SIGWINCH     discard signal       Window size change
 29    SIGINFO      discard signal       status request from keyboard
 30    SIGUSR1      terminate process    User defined signal 1
 31    SIGUSR2      terminate process    User defined signal 2
</code></pre><p>每种信号类型都对应于某种系统事件。</p>
<p>底层的硬件异常是由内核的异常处理程序处理的，正常情况下，对用户进程而言是不可见的。信号提供了一种机制，通知用户发生了这些异常。</p>
<p><strong>传送一个信号到目的进程</strong></p>
<p><code>发送信号：</code> 内核通过更新目的进程上下文中的某个状态，发送一个<em>信号</em>给目的进程。</p>
<p><code>接收信号：</code> 当目的进程被内核强迫以某种方式对信号的发送做出反应时，目的进程就接收了信号。</p>
<h3 id="非本地跳转（nonlocal-jump）"><a href="#非本地跳转（nonlocal-jump）" class="headerlink" title="非本地跳转（nonlocal jump）"></a>非本地跳转（nonlocal jump）</h3><blockquote>
<p>用户级异常控制流形式，将控制直接从一个函数转移到另一个当前正在执行的函数，而不需要经过正常的调用返回序列。</p>
</blockquote>
<p>应用：（1）允许从一个深层嵌套的函数调用中立刻返回，通常是由检测到某个错误情况引起的。<br>(2)使信号处理分支到一个特殊的代码位置，而不是返回到被信号到达中断了的指令位置。</p>
<blockquote>
<p>C++ Java中提供的异常机制是较高层次的，是C语言的setjmp和longjmp的更加结构化的版本，try catch类似于setjmp函数，throw类似于longjmp函数。</p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/07/sort/" itemprop="url">
                  排序算法
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-07T14:34:47+08:00" content="2016-07-07">
              2016-07-07
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>基于Java的算法实现：</p>
<pre><code>public class InsertSort &lt;AnyType extends Comparable&lt;? super AnyType&gt;&gt; {

public void insertionSort(AnyType[] a) {

    int j;

    for(int i = 1; i &lt; a.length; i++) {

        AnyType tmp = a[i];

        for(j = i; j &gt; 0 &amp;&amp; tmp.compareTo(a[j - 1]) &lt; 0; j--) {

            a[j] = a[j - 1];

        }

        a[j] = tmp;


    }

}

public static void main(String[] args) {

    InsertSort&lt;Integer&gt; is = new InsertSort&lt;&gt;();
    Integer[] it = new Integer[10];

    Random rd = new Random();

    for(int i = 0; i &lt; 10; i++) {
        it[i] = rd.nextInt(100);
    }

    is.insertionSort(it);

    for(int i = 0; i &lt; 10; i++) {
        System.out.println(it[i]);
    }

}    
}
</code></pre><p>插入排序算法分析</p>
<p>时间复杂度：O(N²)，如果输入数组已经排序，则时间复杂度为O(N)，如果输入几乎被排序，那么插入排序将运行的很快。</p>
<p>排序算法的下界：可以通过计算排列中的平均逆序数得出插入排序平均运行时间的精确界。</p>
<p><code>定理</code> N个互异数的数组的平均逆序数是N(N-1)/4 </p>
<p><code>定理</code>通过交换相邻元素的任何排序算法都需要Ω(N²)时间 </p>
<p>由上面的定理得知，为了使得一个排序算法以亚二次或者O(N²)时间运行，必须执行一些比较，特别是相对较远的元素的比较以及交换。即每次交换删除不止一个逆序。</p>
<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><pre><code>public void shellSort(AnyType[] a) {

    int j;

    for(int gap = a.length / 2; gap &gt; 0; gap /=2) {

        for(int i = gap; i &lt; a.length; i++) {

            AnyType tmp = a[i];

            for(j = i; j &gt;= gap &amp;&amp; tmp.compareTo(a[j - gap]) &lt; 0; j -= gap) {
                a[j] = a[j - gap];
            }

            a[j] = tmp;

        }

    }

}
</code></pre><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>优先队列可以用于以O(NlogN)时间排序。对于有N个元素的二叉堆，执行N次deleteMin操作，每个deleteMin话费时间O(logN),因此总的运行时间是O(NlogN)，但该算法需要一个附加的数组来盛放从优先队列中取出的单元，所以存储空间增加一倍，不使用额外存储空间的方法是：每次deleteMin操作，将堆的大小缩减1，将堆中最后的单元用来存放刚刚删除的元素。</p>
<p><code>定理：</code> 对N个互异的项随机排列进行堆排序所用比较的平均次数为2NlogN - O(NloglogN)</p>
<pre><code>public class HeapSort {

private static int leftChild(int i) {
    return 2 * i + 1;
}

private static &lt;AnyType extends Comparable&lt;? super AnyType&gt;&gt;  void swapRef(AnyType[] a, int i, int j) {

    AnyType tmp = a[i];
    a[j] = a[i];
    a[i] = tmp;

}

private static &lt;AnyType extends Comparable&lt;? super AnyType&gt;&gt; void percDown(AnyType[] a, int i, int n) {
    int child;
    AnyType tmp;

    for(tmp = a[i]; leftChild(i) &lt; n; i = child) {
        child = leftChild(i);
        if(child != n - 1 &amp;&amp; a[child].compareTo(a[child + 1]) &lt; 0) { 
            child++;
        }
        if(tmp.compareTo(a[child]) &lt; 0) { 
            a[i] = a[child];
        } else {
            break;
        }
    }
    a[i] = tmp;
}

public static &lt;AnyType extends Comparable&lt;? super AnyType&gt;&gt; void heapSort(AnyType[] a) {

    for(int i = a.length / 2; i &gt;= 0; i--) {
        percDown(a,i,a.length);
    }

    for(int i = a.length - 1; i &gt; 0; i--) {
        swapRef(a,0,i);
        percDown(a,0,i);
    }
}

public static void main(String[] args) {
    Random rd = new Random();
    Integer[] it = new Integer[20];

    for(int i  = 0; i &lt; 20; i++) {
        it[i] = rd.nextInt(100);
    }

    for(int i = 0; i &lt; it.length; i++) {
        System.out.println(it[i]);    
    }

    heapSort(it);

    for(int i = 0; i &lt; it.length; i++) {
        System.out.println(it[i]);
    }
}
}
</code></pre><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><pre><code>public class MergeSort {

/**
 * 归并排序运行时间：O(N*logN)
 * 合并两个已经排序的表用到线性附加内存，在整个算法中还要花费将数据拷贝到临时数组再拷贝回来的工作，这种拷贝
 * 可以通过在递归的那些交替层次上谨慎地交换a和tmpArray的角色得以避免。
 * 
 * 与其他O(N*logN)排序算法比较，归并排序的运行时间严重依赖元素的比较以及数组中元素的移动开销。而且这些开
 * 销与所使用的编程语言相关。
 * 在Java中，比较可能相对比较耗时，归并排序使用所有流行的排序算法中最少的比较次数，因此是Java的通用排序算
 * 法中的上好的选择，它是Java标准类库中泛型排序所使用的算法。
 * 
 */


public static &lt;AnyType extends Comparable&lt;? super AnyType&gt;&gt;
void mergeSort(AnyType[] a) {
    AnyType[] tmpArray = (AnyType[]) new Comparable[a.length];
    mergeSort(a,tmpArray,0,a.length - 1);
}


private static &lt;AnyType extends Comparable&lt;? super AnyType&gt;&gt;
void mergeSort(AnyType a[], AnyType[] tmpArray, int left, int right) {

    if(left &lt; right) {
        int center  = (left + right) / 2;
        mergeSort(a,tmpArray,left,center);
        mergeSort(a,tmpArray,center + 1, right);
        merge(a,tmpArray,left,center + 1,right);
    }

}

private static &lt;AnyType extends Comparable&lt;? super AnyType&gt;&gt; 
void merge(AnyType[] a, AnyType[] tmpArray, int leftPos, int rightPos, int rightEnd) {

    int leftEnd = rightPos - 1;
    int tmpPos = leftPos;
    int numElement = rightEnd - leftPos + 1;

    while(leftPos &lt;= leftEnd &amp;&amp; rightPos &lt;= rightEnd) {
        if(a[leftPos].compareTo(a[rightPos]) &lt; 0) {
            tmpArray[tmpPos++] = a[leftPos++];
        } else {
            tmpArray[tmpPos++] = a[rightPos++];
        }
    }

    while(leftPos &lt;= leftEnd) {
        tmpArray[tmpPos++] = a[leftPos++];
    }

    while(rightPos &lt;= rightEnd) {
        tmpArray[tmpPos++] = a[rightPos++];
    }

    for(int i = 0; i &lt; numElement; i++, rightEnd--) {
        a[rightEnd] = tmpArray[rightEnd];
    }

}

public static void main(String[] args) {
    Random rd = new Random();
    Integer[] a = new Integer[100000];
    for(int i = 0; i &lt; 100000; i++) {
        a[i] = rd.nextInt(100);
        System.out.println(i + &quot;------&gt;&quot; + a[i]);
    }

    mergeSort(a);
    System.out.println(&quot;归并排序完毕&quot;);
    for(int i = 0; i &lt; 100; i++) {
        System.out.println(i + &quot;------&gt;&quot; + a[i]);
    }
}
}
</code></pre><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><pre><code>public class QuickSort &lt;AnyType extends Comparable&lt;? super AnyType&gt;&gt; {

/**
 * 分治递归算法
 * 平均运行时间：O(N*logN)
 * 
 */
private final int CUTOFF = 10;

public void quickSort(AnyType[] a) {
    quickSort(a, 0, a.length - 1);
}

private void quickSort(AnyType[] a, int left, int right) {
    if(left + CUTOFF &lt;= right) { //排序的元素数量足够多的时候选用快速排序，否则选用插入排序性能更好。
        System.out.println(&quot;选择快速排序&quot;);
        AnyType pivot = median3(a,left,right);
        int i = left;
        int j = right - 1;
        for(;;) {
            while(a[++i].compareTo(pivot) &lt; 0) {}
            while(a[--j].compareTo(pivot) &gt; 0) {}
            if(i &lt; j) {
                swapReferences(a,i,j);
            } else {
                break;
            }
        }
        //将pivot放回原位
        swapReferences(a,i,right - 1);
        //递归 分治
        quickSort(a,left,i - 1);
        quickSort(a,i + 1, right);

    } else {
        // insertSort();
    }
}

private AnyType median3(AnyType[] a, int left, int right) {

    int center = (left + right) / 2;
    if(a[center].compareTo(a[left]) &lt; 0) {
        swapReferences(a,center,left);
    }
    if(a[right].compareTo(a[left]) &lt; 0) {
        swapReferences(a,left,right);
    }
    if(a[right].compareTo(a[center]) &lt; 0) {
        swapReferences(a,center,right);
    }
    //right 这个位置上保存的值大于center，所以交换center 和 right - 1
    swapReferences(a, center,right - 1);
    return a[right - 1];
}


private void swapReferences(AnyType[] a, int i, int j) {
    Object tmp = new Object();
    tmp = a[i];
    a[i] = a[j];
    a[j] = (AnyType) tmp;
}

public static void main(String[] args) {
    Integer[] a = new Integer[100];
    QuickSort qs = new QuickSort();
    Random rd = new Random();
    for(int i = 0; i &lt; 100; i++) {
        a[i] = rd.nextInt(100);
        System.out.println(i + &quot;: -----------&gt;&quot; + a[i]);
    }
    qs.quickSort(a);
    for(int i = 0; i &lt; 100; i++) {
        System.out.println(i + &quot;: -----------&gt;&quot; + a[i]);
    }
}
}
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/07/ds/" itemprop="url">
                  一些数据结构
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-07T14:33:37+08:00" content="2016-07-07">
              2016-07-07
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <pre><code>public class MyTreeSet&lt;AnyType extends Comparable&lt;? super AnyType&gt;&gt;{

private BinaryNode&lt;AnyType&gt; root;
int modCount = 0;


private static class BinaryNode&lt;AnyType&gt; {   

    AnyType element; 
    BinaryNode&lt;AnyType&gt; left;
    BinaryNode&lt;AnyType&gt; right;
    BinaryNode&lt;AnyType&gt; parent;

    BinaryNode(AnyType theElement, BinaryNode&lt;AnyType&gt; lt,BinaryNode&lt;AnyType&gt; rt, BinaryNode&lt;AnyType&gt; pt) {

        this.element = theElement;
        this.left = lt;
        this.right = rt;
        this.parent = pt;

    }

    BinaryNode(AnyType theElement) {
        this(theElement,null,null,null);
    }


}

public Iterator&lt;AnyType&gt; iterator() {

    return new MyTreeSetIterator();

}


private class MyTreeSetIterator implements Iterator&lt;AnyType&gt; {

    private BinaryNode&lt;AnyType&gt; current = findMin(root);
    private BinaryNode&lt;AnyType&gt; previous;
    private int expectedModCount = modCount;
    private boolean okToRemove = false;
    private boolean atEnd = false;




    @Override
    public boolean hasNext() {

        return !atEnd;

    }

    @Override
    public AnyType next() {

        if(expectedModCount != modCount) {
            throw new ConcurrentModificationException();
        }

        if(!hasNext()) {
            throw new NoSuchElementException();
        }

        AnyType nextItem = current.element; //获取当前节点的元素

        previous = current; //当前节点变成前一个节点

        //获取下一个节点作为当前节点
        //情况1 当前节点有右子树，那么下一个节点是右子树的最小值
        //情况2 当前节点没有右子树，向上找父节点，直到当前节点是父节点的左子树为止，因为左子树比父节点小，而右子树比父节点大

        if(current.right != null) {

            current = findMin(current.right);

        } else {

            BinaryNode&lt;AnyType&gt; child = current;
            current = current.parent;

            while(current != null &amp;&amp; current.left != child) { //父节点不为空，且当前节点不是父节点的左子树,则继续寻找

                child = current;
                current = current.parent;

            }

            if(current == null) {
                atEnd = true;
            }


        }

        okToRemove = true;

        return nextItem;
    }


    public void remove() {

        if(modCount != expectedModCount) {
            throw new ConcurrentModificationException();
        }

        if(!okToRemove) {
            throw new IllegalStateException();
        }

        MyTreeSet.this.remove(previous.element);
        okToRemove = false;


    }

}


public MyTreeSet() {
    root = null;
}

public void makeEmpty() {
    modCount ++;
    root = null;
}

public boolean isEmpty() {
    return root == null;
}

public boolean contains(AnyType x) {
    return contains(x,root);
}

public void insert(AnyType x) {
    root = insert(x,root,null);
}


public void remove(AnyType x) {
    root = remove(x,root);
}

public AnyType findMin() throws UnderFlowException {

    if(isEmpty()) {
        throw new UnderFlowException();
    }

    return findMin(root).element;

}

public AnyType findMax() throws UnderFlowException {

    if(isEmpty()) {
        throw new UnderFlowException();
    }

    return findMax(root).element;

}


public void printTree() {

    if(isEmpty()) {
        System.out.println( &quot;Empty tree !&quot; );
    } else {
        printTree(root);
    }

}


private void printTree(BinaryNode&lt;AnyType&gt; t) {

    if(t != null) {

        printTree(t.left);
        System.out.println(t.element);
        printTree(t.right);

    }

}



private boolean contains(AnyType x, BinaryNode&lt;AnyType&gt; t) {

    if(t == null) {
        return false;
    }

    int compareResult = x.compareTo(t.element);

    if(compareResult &lt; 0) {

        return contains(x,t.left);

    } else if(compareResult &gt; 0) {

        return contains(x,t.right);

    } else {

        return true;

    }

}

private BinaryNode&lt;AnyType&gt; findMin(BinaryNode&lt;AnyType&gt; t) {

    if(t == null) {
        return null;
    } else if(t.left == null) {
        return t;
    } else {
        return findMin(t.left);
    }

}

private BinaryNode&lt;AnyType&gt; findMax(BinaryNode&lt;AnyType&gt; t) {

    if(t == null) {
        return null;
    } else if (t.right == null) {
        return t;
    } else {
        return findMax(t.right);
    }

}

private BinaryNode&lt;AnyType&gt; insert(AnyType x, BinaryNode&lt;AnyType&gt; t, BinaryNode&lt;AnyType&gt; pt) {

    if(t == null) {
        modCount++;
        return new BinaryNode&lt;AnyType&gt;(x,null,null,pt);
    }

    int compareResult = x.compareTo(t.element);

    if(compareResult &lt; 0) {
        return insert(x,t.left,t);
    } else if(compareResult &gt; 0) {
        return insert(x,t.right,t);
    } else {
        //重复
    }


    return t;

}

private BinaryNode&lt;AnyType&gt; remove(AnyType x, BinaryNode&lt;AnyType&gt; t) {

    if(t == null) {
        return t; //not found
    }

    int compareResult = x.compareTo(t.element);

    if(compareResult &lt; 0) {
        return remove(x,t.left);
    } else if (compareResult &gt; 0) {
        return remove(x,t.right);
    } else if (t.left != null &amp;&amp; t.right != null) { //左右子树全不为空
        t.element = findMin(t.right).element; //用t的右子树的最小值代替t的位置
        t.right = remove(t.element,t.right);
    } else {
        modCount ++;
        BinaryNode&lt;AnyType&gt; oneChild;
        oneChild = (t.left != null) ? t.left : t.right;
        oneChild.parent = t.parent;
        t = oneChild;
    }

    return t;


}

public static void main(String[] args) {

    MyTreeSet&lt;Integer&gt; treeSet = new MyTreeSet&lt;&gt;();

    for(int i = 0; i &lt; 10; i++) {
        treeSet.insert(i);
    }

    try {
        System.out.println(treeSet.findMin());
    } catch (UnderFlowException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }
}
}
class UnderFlowException extends Exception {

}






public class SeparateChainingHashTable&lt;AnyType&gt; {

private static final int DEFAULT_TABLE_SIZE = 10;

private List&lt;AnyType&gt;[] theList; 

private int currentSize;

public SeparateChainingHashTable() {
    this(DEFAULT_TABLE_SIZE);
}

public SeparateChainingHashTable(int size) {

    theList = new LinkedList[nextPrime(size)];

    for(int i = 0; i &lt; theList.length; i++) {
        theList[i] = new LinkedList&lt;AnyType&gt;();
    }

}

public void makeEmpty() {
    for(int i = 0; i &lt; theList.length; i++) {
        theList[i].clear();
    }
}

public boolean contains(AnyType x) {

    List&lt;AnyType&gt; whichList = theList[myHash(x)];
    return whichList.contains(x);

}

public void insert(AnyType x) {

    List&lt;AnyType&gt; whichList = theList[myHash(x)];
    if(!whichList.contains(x)) { 
        whichList.add(x);

        if(++currentSize &gt; theList.length) {
            rehash();
        }
    }
}

public void remove(AnyType x) {
    List&lt;AnyType&gt; whichList = theList[myHash(x)];
    if(whichList.contains(x)) {
        whichList.remove(x);
        currentSize--;
    }
}

private int myHash(AnyType x) {
    int hashVal = x.hashCode();
    hashVal %= theList.length;
    if(hashVal &lt; 0) {
        hashVal += theList.length;
    }
    return hashVal;
}

private static int nextPrime(int n) {
    if( n % 2 == 0 )
        n++;

    for( ; !isPrime( n ); n += 2 )
        ;

    return n;
}

private static boolean isPrime(int n) {
    if( n == 2 || n == 3 )
        return true;

    if( n == 1 || n % 2 == 0 )
        return false;

    for( int i = 3; i * i &lt;= n; i += 2 )
        if( n % i == 0 )
            return false;

    return true;
}

private void rehash() {

    List&lt;AnyType&gt;[] oldArray = theList;

    theList = new LinkedList[nextPrime(2 * theList.length)];

    for(int i = 0; i &lt; theList.length; i++) {
        theList[i] = new LinkedList&lt;AnyType&gt;();
    }

    for(int i = 0; i&lt; oldArray.length; i++) {
//theList[i] = oldArray[i]; 
//注意：这里不能这样写，因为rehash后，HashTable的大小发生改变，所以原来所有元素的存储位置都随之发生改变，正确的做法如下：
    for(AnyType item : oldArray[i]) {
            insert(item);
    }

}

}
}




public class BinarySearch {

//折半搜索每次把搜索区域减少一半，时间复杂度为 O(logN).
//空间复杂度：O(1).

//递归
public static int bs1(final int[] array, int start,int end, int key) {

    if(start &gt; end) {
        return -1;
    }

    int mid = start + (end - start) / 2;

    if(array[mid] &gt; key) {
        return bs1(array, start, mid-1, key);
    } else if(array[mid] &lt; key) {
        return bs1(array, mid + 1, end,key);
    }
    return mid;
}


public static int bs2(final int[] array, int start, int end, int key) {

    int mid;

    while(end / 2 &gt; 0) {
        mid = start + (end - start) /2;
        if(array[mid] &gt; key) {
            start = mid + 1;
        } else if(array[mid] &lt; key) {
            end = mid - 1;
        }
        return mid;
    }

    return -1;
}



public static void main(String[] args) {

    int[] aim = {1,2,3,4,5,6,7,8,9,10};
    System.out.println(bs2(aim,0,9,5));

}
}

public class BinarySearchTree&lt;AnyType extends Comparable&lt;? super AnyType&gt;&gt; {

private static class BinaryNode&lt;AnyType&gt; {
    AnyType element;
    BinaryNode&lt;AnyType&gt; left;
    BinaryNode&lt;AnyType&gt; right;

    public BinaryNode(AnyType element,BinaryNode&lt;AnyType&gt; left,BinaryNode&lt;AnyType&gt; right) {
        this.element = element;
        this.left = left;
        this.right = right;
    }

    public BinaryNode(AnyType element) {
        this(element,null,null);
    }
}

private BinaryNode&lt;AnyType&gt; root;

public BinarySearchTree() {
    root = null;
}

public boolean isEmpty() {
    return root == null;
}

public void makeEmpty() {
    root = null;
}

public boolean contains(AnyType x) {
    return contains(x,root);
}

private boolean contains(AnyType x, BinaryNode&lt;AnyType&gt; t) {

    if(t == null) {
        return false;
    }

    int compareResult = x.compareTo(t.element);

    if(compareResult &gt; 0) {
        return contains(x,t.right);
    } else if(compareResult &lt; 0) {
        return contains(x,t.left);
    } else {
        return true;
    }

}

private BinaryNode&lt;AnyType&gt; findMin(BinaryNode&lt;AnyType&gt; t) {
    if(t == null) {
        return null;
    } else if(t.left == null) {
        return t;
    }
    return findMin(t.left);
}

private BinaryNode&lt;AnyType&gt; findMax(BinaryNode&lt;AnyType&gt; t) {
    if(t != null) {
        while(t.right != null){
            t = t.right;
        }
    }
    return t;
}

private BinaryNode&lt;AnyType&gt; insert(AnyType x, BinaryNode&lt;AnyType&gt; t) {
    if(t == null) {
        return new BinaryNode&lt;AnyType&gt;(x,null,null);
    }

    int compareResult = x.compareTo(t.element);

    if(compareResult &lt; 0) {
        insert(x,t.left);
    } else if(compareResult &gt; 0) {
        insert(x,t.right);
    } else {

    }
    return t;
}

/**
 * 
 * @param x
 * @param t
 * @return 
 */
private BinaryNode&lt;AnyType&gt; remove(AnyType x, BinaryNode&lt;AnyType&gt; t) {
    if(t == null) {
        return t; 
    }

    int compareResult = x.compareTo(t.element);

    if(compareResult &lt; 0) {
        remove(x,t.left);
    } else if(compareResult &gt; 0) {
        remove(x,t.right);
    } else 
        if(t.left != null &amp;&amp; t.right != null) {
        t.element = findMin(t.right).element;
        t.right = remove(x,t.right);
        } else {
            t = (t.left != null) ? t.left : t.right;
        }
    return t;
}

}
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/07/RxJava/" itemprop="url">
                  RxJava
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-07T14:07:43+08:00" content="2016-07-07">
              2016-07-07
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/源码/" itemprop="url" rel="index">
                    <span itemprop="name">源码</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://gank.io/post/560e15be2dca930e00da1083" target="_blank" rel="external">学习高手的文章《给 Android 开发者的 RxJava 详解》</a></p>
<p>RxJava: Reactive Extensions for the JVM</p>
<p>RxJava is a Java VM implementation of Reactive Extensions: a library for composing asynchronous and event-based programs by using observable sequences.</p>
<p>It extends the observer pattern to support sequences of data/events and adds operators that allow you to compose sequences together declaratively while abstracting away concerns about things like low-level threading, synchronization, thread-safety and concurrent data structures.</p>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p><strong>异步</strong></p>
<p><strong>简洁</strong></p>
<p>把复杂的逻辑串成一条简单的线</p>
<h3 id="API及原理"><a href="#API及原理" class="headerlink" title="API及原理"></a>API及原理</h3><ul>
<li>扩展的观察者模式</li>
</ul>
<p>被观察者：Observable<br>观察者：Observer</p>
<p>订阅：Subscribe()</p>
<p>Observable 和 Observer通过 subscribe()方法实现订阅关系</p>
<p>RxJava事件回调方法：</p>
<pre><code>onNext()
onComplete()
onError()
</code></pre><p>创建Observer 观察者，它决定事件触发的时候将有怎样的行为</p>
<pre><code>Observer&lt;String&gt; observer = new Observer&lt;String&gt;() {
    @Override
    public void onCompleted() {

    }

    @Override
    public void onError(Throwable e) {

    }

    @Override
    public void onNext(String str) {

    }
};
</code></pre><p>还有一个实现了Observer的抽象类Subscriber（订阅者）</p>
<pre><code>class MySubscriber extends Subscriber&lt;String&gt; {

    @Override
    public void onCompleted() {

    }

    @Override
    public void onError(Throwable e) {
        e.printStackTrace();
    }

    @Override
    public void onNext(String s) {
        Log.i(Tag,s);
    }

    //该方法可选，在subscribe刚开始，事件发送之前被调用，可用于做一些准备工作。在subscribe发生的线程被调用
    @Override
    public void onStart() {
        super.onStart();
    }
}
</code></pre><p>Subscriber.unSubscribe() 取消订阅，防止内存泄露</p>
<p>被观察者Observable</p>
<pre><code>Observable observable = Observable.create(new Observable.OnSubscribe&lt;String&gt;() {
    @Override
    public void call(Subscriber&lt;? super String&gt; subscriber) {
        subscriber.onNext(&quot;Hello RxJava&quot;);
        subscriber.onCompleted();
    }
});
</code></pre><p>当observable被订阅的时候，OnSubscribe的call方法会被自动调用，即可调用subscriber的相关回调方法。</p>
<p>Subscribe 将观察者和被观察者连接起来</p>
<pre><code>observable.subscribe(new MySubscriber());
</code></pre><p>subscribe内部实现：</p>
<pre><code>static &lt;T&gt; Subscription subscribe(Subscriber&lt;? super T&gt; subscriber, Observable&lt;T&gt; observable) {
    if (subscriber == null) {
        throw new IllegalArgumentException(&quot;subscriber can not be null&quot;);
    }
    if (observable.onSubscribe == null) {
        throw new IllegalStateException(&quot;onSubscribe function can not be null.&quot;);
    }
    subscriber.onStart();
    if (!(subscriber instanceof SafeSubscriber)) {
        subscriber = new SafeSubscriber&lt;T&gt;(subscriber);
    }
    try {
        hook.onSubscribeStart(observable, observable.onSubscribe).call(subscriber);
        return hook.onSubscribeReturn(subscriber);
    } catch (Throwable e) {
        Exceptions.throwIfFatal(e);
        if (subscriber.isUnsubscribed()) {
            RxJavaPluginUtils.handleException(hook.onSubscribeError(e));
        } else {
            try {
                subscriber.onError(hook.onSubscribeError(e));
            } catch (Throwable e2) {
                Exceptions.throwIfFatal(e2);
                RuntimeException r = new OnErrorFailedException(&quot;Error occurred attempting to subscribe [&quot; + e.getMessage() + &quot;] and then again while trying to pass to onError.&quot;, e2);
                hook.onSubscribeError(r);
                throw r;
            }
        }
        return Subscriptions.unsubscribed();
    }
}
</code></pre><p>上述源码的主要功能实现：</p>
<pre><code>//调用观察者的onStart()方法
subscriber.onStart(); 
//钩子，调用subscriber的回调方法
hook.onSubscribeStart(observable, observable.onSubscribe).call(subscriber);
//将传入的subscriber作为subscription返回，便于unSubscribe
return hook.onSubscribeReturn(subscriber);
</code></pre><h3 id="线程控制"><a href="#线程控制" class="headerlink" title="线程控制"></a>线程控制</h3><p>在RxJava的默认规则中，事件的发出和消费是在同一个线程中。如果要实现异步机制，就需要用到调度器Scheduler</p>
<pre><code>Scheduler.immediate() 直接在当前线程运行，相当于不指定线程
Schedulers.newThread(): 总是启用新线程，并在新线程执行操作。
Schedulers.io(): I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的 Scheduler。行为模式和 newThread() 差不多，区别在于 io() 的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下 io() 比 newThread() 更有效率。不要把计算工作放在 io() 中，可以避免创建不必要的线程。
Schedulers.computation(): 计算所使用的 Scheduler。这个计算指的是 CPU 密集型计算，即不会被 I/O 等操作限制性能的操作，例如图形的计算。这个 Scheduler 使用的固定的线程池，大小为 CPU 核数。不要把 I/O 操作放在 computation() 中，否则 I/O 操作的等待时间会浪费 CPU。
另外， Android 还有一个专用的 AndroidSchedulers.mainThread()，它指定的操作将在 Android 主线程运行。
</code></pre><p>线程控制方法：</p>
<pre><code>subscribeOn() 指定事件产生的线程
onserverOn() 指定事件消费的线程

observable.subscribeOn(Schedulers.io())
            .observeOn(AndroidSchedulers.mainThread())
            .subscribe(new MySubscriber());
</code></pre><p><strong>Scheduler原理</strong></p>
<p>变换：</p>
<p>如：将网络上获取的Json数据转换为JavaBean</p>
<p>map()</p>
<pre><code>//将输入的String类型变换为Bitmap类型
Observable.just(&quot;images/logo.png&quot;) // 输入类型 String
.map(new Func1&lt;String, Bitmap&gt;() {
    @Override
    public Bitmap call(String filePath) { // 参数类型 String
        return getBitmapFromPath(filePath); // 返回类型 Bitmap
    }
})
.subscribe(new Action1&lt;Bitmap&gt;() {
    @Override
    public void call(Bitmap bitmap) { // 参数类型 Bitmap
        showBitmap(bitmap);
    }
});
</code></pre><p>flatMap() 使用传入的事件对象创建一个Observable，激活这个Observable，开始发送事件，然后将每个激活的Observable发送的事件汇总到一个Observable统一交给Subscriber的回调方法。</p>
<pre><code>Student[] students = ...;
Subscriber&lt;Course&gt; subscriber = new Subscriber&lt;Course&gt;() {
@Override
public void onNext(Course course) {
    Log.d(tag, course.getName());
}
...
};
Observable.from(students)
.flatMap(new Func1&lt;Student, Observable&lt;Course&gt;&gt;() {
    @Override
    public Observable&lt;Course&gt; call(Student student) {
        return Observable.from(student.getCourses());
    }
})
.subscribe(subscriber);
</code></pre><p>flatMap()常用于嵌套的异步操作，如：Retrofit + RxJava 异步网络请求。</p>
<p>变换的原理：lift()</p>
<pre><code>public final &lt;R&gt; Observable&lt;R&gt; lift(final Operator&lt;? extends R, ? super T&gt; operator) {
    return new Observable&lt;R&gt;(new OnSubscribeLift&lt;T, R&gt;(onSubscribe, operator));
}

public final class OnSubscribeLift&lt;T, R&gt; implements OnSubscribe&lt;R&gt; {

static final RxJavaObservableExecutionHook hook =     RxJavaPlugins.getInstance().getObservableExecutionHook();

final OnSubscribe&lt;T&gt; parent;

final Operator&lt;? extends R, ? super T&gt; operator;

public OnSubscribeLift(OnSubscribe&lt;T&gt; parent, Operator&lt;? extends R, ? super T&gt; operator)     {
    this.parent = parent;
    this.operator = operator;
}

@Override
public void call(Subscriber&lt;? super R&gt; o) {
    try {
        Subscriber&lt;? super T&gt; st = hook.onLift(operator).call(o);
        try {
            // new Subscriber created and being subscribed with so &apos;onStart&apos; it
            st.onStart();
            parent.call(st);
        } catch (Throwable e) {
            // localized capture of errors rather than it skipping all operators 
            // and ending up in the try/catch of the subscribe method which then
            // prevents onErrorResumeNext and other similar approaches to error handling
            Exceptions.throwIfFatal(e);
            st.onError(e);
        }
    } catch (Throwable e) {
        Exceptions.throwIfFatal(e);
        // if the lift function failed all we can do is pass the error to the final Subscriber
        // as we don&apos;t have the operator available to us
        o.onError(e);
    }
}
}
</code></pre><p>在 Observable 执行了 lift(Operator) 方法之后，会返回一个新的 Observable，这个新的 Observable 会像一个代理一样，负责接收原始的 Observable 发出的事件，并在处理后发送给 Subscriber。</p>
<h3 id="RxJava与Retrofit结合异步网络请求实例"><a href="#RxJava与Retrofit结合异步网络请求实例" class="headerlink" title="RxJava与Retrofit结合异步网络请求实例"></a>RxJava与Retrofit结合异步网络请求实例</h3><pre><code>public interface MobileAPIData {
     @GET(&quot;/Uploader/Circle&quot;)
    Observable&lt;UserCircleWrapForClient&gt; loadCircle(@QueryMap Map&lt;String, String&gt; options);
}


public class HttpMethods {
    private static final int DEFAULT_TIMEOUT = 5;
    private Retrofit retrofit;
    private MobileAPIData apiService;
    private OkHttpClient.Builder builder;

    private HttpMethods() {
        builder = new OkHttpClient.Builder();
        builder.connectTimeout(DEFAULT_TIMEOUT, TimeUnit.SECONDS);
    }

    private static class SingletonHolder {
        private static final HttpMethods instance = new HttpMethods();
    }

    public static HttpMethods getInstance() {
        return SingletonHolder.instance;
    }

    public void loadCircleByIdAndTimestamp(Subscriber&lt;UserCircleWrapForClient&gt; subscriber, String url, Map&lt;String,String&gt; map) {
        retrofit = new Retrofit.Builder()
            .client(builder.build())
            .addConverterFactory(GsonConverterFactory.create())
            .addCallAdapterFactory(RxJavaCallAdapterFactory.create())
            .baseUrl(url)
            .build();
        apiService = retrofit.create(MobileAPIData.class);
        apiService.loadCircle(map)
            .subscribeOn(Schedulers.io())
            .unsubscribeOn(Schedulers.io())
            .observeOn(AndroidSchedulers.mainThread())
            .subscribe(subscriber);
    }
}

//使用
private void refreshData() {
    circleSubscriber = new CircleSubscriber();
    Map&lt;String, String&gt; map = makeOptions();
    HttpMethods.getInstance().loadCircleByIdAndTimestamp(circleSubscriber,API.BASE_URL,map);
}

private class CircleSubscriber extends Subscriber&lt;UserCircleWrapForClient&gt; {

    @Override
    public void onCompleted() {
        progressBar.setVisibility(View.GONE);
    }

    @Override
    public void onError(Throwable e) {

    }

    @Override
    public void onNext(UserCircleWrapForClient userCircleWrapForClient) {
        if(userCircleWrapForClient.getErrorType().equals(Constants.TYPE_NO_ERROR)) {
            UserCircle circle = userCircleWrapForClient.getCircle();
            int commentCount = circle.getComments().size();
            loadmore.setText(String.valueOf(commentCount) + &quot;评论, 点击加载&quot;);
        } else if (userCircleWrapForClient.getErrorType().equals(Constants.TYPE_ERROR)){
            loadmore.setText(userCircleWrapForClient.getErrorType());
        }
    }
}
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/27/mysqlinnodb/" itemprop="url">
                  MySQL技术内幕 InnoDB存储引擎 读书笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-27T19:05:51+08:00" content="2016-06-27">
              2016-06-27
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/数据库/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="MySQL技术内幕"><a href="#MySQL技术内幕" class="headerlink" title="MySQL技术内幕"></a>MySQL技术内幕</h1><h2 id="MySQL体系结构和存储引擎"><a href="#MySQL体系结构和存储引擎" class="headerlink" title="MySQL体系结构和存储引擎"></a>MySQL体系结构和存储引擎</h2><h3 id="数据库和数据库实例"><a href="#数据库和数据库实例" class="headerlink" title="数据库和数据库实例"></a>数据库和数据库实例</h3><p>数据库：文件的集合，是依照某种数据模型组织起来并存放于二级存储器中的数据集合</p>
<p>数据库实例：进程/线程，是应用程序，是位于用户和操作系统之间的一层数据库管理软件</p>
<p>在MySQL中，数据库和数据库实例通常是一一对应关系，在集群情况下有可能存在单一数据库被多个实例访问的情况</p>
<p>MySQL是单进程多线程的数据结构</p>
<p>启动数据库查看数据库进程</p>
<p>bym$ mysql.server start<br>Starting MySQL<br>SUCCESS!<br>bym$ ps -ef | grep mysqld<br>501  1000     1   0  3:56下午 ttys000    0:00.02 /bin/sh /usr/local/Cellar/mysql/5.7.11/bin/    mysqld_safe –datadir=/usr/local/var/mysql –pid-file=/usr/local/var/mysql/BYMdeMac-mini.local.pid<br>501  1092  1000   0  3:56下午 ttys000    0:00.35 /usr/local/Cellar/mysql/5.7.11/bin/mysqld –basedir=/usr/local/Cellar/mysql/5.7.11 –datadir=/usr/local/var/mysql –plugin-dir=/usr/local/Cellar/mysql/5.7.11/lib/plugin –log-error=/usr/local/var/mysql/BYMdeMac-mini.local.err –pid-file=/usr/local/var/mysql/BYMdeMac-mini.local.pid<br>501  1094   992   0  3:56下午 ttys000    0:00.00 grep mysqld</p>
<p>cd到MySQL的bin文件夹执行下边的命令查询MySQL，启动时读取的配置文件，Linux环境下，MySQL的配置文件在<code>/etc/my.cnf</code></p>
<p>BYMdeMac-mini:bin bym$ ./mysql –help | grep my.cnf<br>order of preference, my.cnf, $MYSQL_TCP_PORT,/etc/my.cnf /etc/mysql/my.cnf /usr/local/etc/my.cnf ~/.my.cnf</p>
<h3 id="MySQL体系结构如图："><a href="#MySQL体系结构如图：" class="headerlink" title="MySQL体系结构如图："></a>MySQL体系结构如图：</h3><p><img src="/images/mysql.png" alt="MySQLStructure"></p>
<p>MySQL的最大特点是插件式存储引擎</p>
<p>新建表 更换存储引擎</p>
<p>mysql&gt; create table mytest engine=myisam as select * from providers;<br>Query OK, 93 rows affected (0.01 sec)<br>Records: 93  Duplicates: 0  Warnings: 0</p>
<p>mysql&gt; alter table mytest engine=innodb;<br>Query OK, 93 rows affected (0.02 sec)<br>Records: 93  Duplicates: 0  Warnings: 0</p>
<p>连接MySQL</p>
<ul>
<li>TCP/IP套接字</li>
<li>命名管道、共享内存（两个需要通信的进程在同一个服务器上）</li>
<li>Unix套接字</li>
</ul>
<h2 id="InnoDB存储引擎概述"><a href="#InnoDB存储引擎概述" class="headerlink" title="InnoDB存储引擎概述"></a>InnoDB存储引擎概述</h2><p>事务安全</p>
<p>第一个完整支持ACID事务的MySQL存储引擎。一致性非锁定读，支持外键。</p>
<p><strong>InnoDB架构</strong></p>
<p>InnoDB有多个内存块构成存储引擎内存池，还有多个后台线程。</p>
<p>内存池：维护所有进程/线程需要访问的多个内部数据结构，缓存磁盘上的数据方便快速读取，并在对磁盘文件上的数据进行修改之前在这里缓存，重做日志缓冲。<br>包括：缓冲池，重做日志缓冲池，额外的内存池</p>
<p>//缓冲池，占最大块内存，将数据库文件按页（16KB）读取到缓冲池，按照最近最少使用算法（LRU）来保留在缓冲池的缓存数据。数据文件修改，首先修改缓冲池中的页，然后再按照一定的频率将修改后的脏页flush到文件中。<br>show engine innodb status;<br>数据页<br>索引页<br>插入缓冲<br>自适应哈希索引<br>锁信息<br>数据字典信息</p>
<p>后台线程：刷新内存池中的数据，确保缓存的是最近的数据，将已修改的数据文件刷新到磁盘文件，同时保证在数据库异常的情况下InnoDB能恢复到正常运行状态。<br>包括：IOThread masterThread 锁监控线程 错误监控线程</p>
<p>InnoDB的主要工作是在masterThread中完成的。masterThread的优先级最高，masterThread中包含如下循环：<br>loop 主循环：每秒一次和10秒一次操作<br>每秒一次：<br>日志缓冲刷新到磁盘（总是）<br>合并插入缓冲（可能）<br>最多刷新100个InnoDB的缓冲池脏页到磁盘（可能）<br>如果当前没有用户活动，切换到background loop（可能）<br>每10秒一次：<br>刷新100个InnoDB的缓冲池脏页到磁盘（可能）<br>合并最多5个插入缓冲（总是）<br>日志缓冲刷新到磁盘（总是）<br>删除无用Undo页（总是）<br>刷新100个或者10个脏页到磁盘（总是）<br>产生一个检查点（总是）</p>
<p>background loop 后台循环<br>删除无用的Undo页（总是）<br>合并20个插入缓冲（总是）<br>调回到主循环（总是）<br>不断刷新100个页，直到符合条件(有可能在flush loop中实现)<br>flush loop 刷新循环<br>suspend loop 暂停循环</p>
<p>InnoDB Plugin提供了参数innodb_io_capacity，表示磁盘IO的吞吐量，InnoDB Plugin会根据该吞吐量，按照一定的百分比来刷新相对数量的页。</p>
<p>innodb_max_dirty_pages_pct，默认值为90%，如果内存很大或者数据库压力很大，刷新脏页的速度会降低。InnoDB Plugin 将该值改为75%，加快脏页的刷新频率，保证磁盘IO的负载。</p>
<p>innodb_adaptive_flushing 自适应刷新，该参数的引入使得InnoDB通过一个名为buf_flush_get_desired_flush_rate的函数来判断需要刷新的脏页最合适的数量。使得当脏页比例小于innodb_max_dirty_pages_pct时也会刷新。提高了性能。</p>
<p><strong>关键特性</strong></p>
<ul>
<li>插入缓存</li>
</ul>
<p>应对非聚集索引插入的离散型导致的性能下降，InnoDB存储引擎开创性的设计了插入缓冲。对于非聚集索引的插入或者更新操作，不是每次直接插入到索引页，而是先判断插入的非聚集索引是否在缓冲池中，如果在，则直接插入，如果不在，则先放入一个插入缓冲区，然后再以一定的频率执行插入缓冲和非聚集索引页子节点的合并操作，这时通常能够将多个插入合并到一个操作中，提高了对非聚集索引执行插入和修改操作的性能。</p>
<ul>
<li>doublewrite</li>
<li>自适应哈希索引</li>
</ul>
<h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><ul>
<li>参数文件：数据库文件所在位置，初始化参数。</li>
<li>日志文件</li>
<li>socket文件</li>
<li>pid文件</li>
<li>MySQL表结构文件</li>
<li>存储引擎文件</li>
</ul>
<h2 id="表"><a href="#表" class="headerlink" title="表"></a>表</h2><p>表是关于特定实体的数据集合，是关系型数据库模型的核心。</p>
<p>所有数据都被逻辑地存放在一个空间中，即表空间（tablesspace），表空间由段（segment），区（extent），页（page）组成。</p>
<p>段：数据段 索引段，回滚段，InnoDB的引擎表是索引组织的，因此数据即索引，索引即数据。数据段即B+树的叶节点，索引段即B+树的非叶点。</p>
<p>区：64个连续的页，每个页16KB，每个区1MB，大的数据段，InnoDB最多每次可以申请4个区，以此来保证数据的顺序性能。</p>
<p>页：是InnoDB磁盘管理的最小单位。</p>
<p>数据页 B-tree Node<br>Undo页<br>系统页<br>事务数据页<br>插入缓冲区位图页<br>插入缓冲区空闲列表页<br>未压缩的二进制大对象页<br>压缩的二进制大对象页</p>
<p>行：</p>
<h2 id="数据库索引算法"><a href="#数据库索引算法" class="headerlink" title="数据库索引算法"></a>数据库索引算法</h2><p>二分查找<br>B+树存储  聚集索引 辅助索引</p>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>锁机制是数据库系统区别于文件系统的一个关键特性，用于管理对共享资源的并发访问。</p>
<p>InnoDB存储引擎提供一致性的非锁定读，行级锁支持，行级锁没有相关的开销，可以同时得到并发性和一致性。</p>
<p><strong>锁的类型</strong></p>
<ul>
<li>共享锁 允许事务读取一行数据；</li>
<li>排他锁 允许事务更新或删除一条数据。</li>
</ul>
<p>一致性非锁定读，读取快照。</p>
<h2 id="事务（Transaction）"><a href="#事务（Transaction）" class="headerlink" title="事务（Transaction）"></a>事务（Transaction）</h2><p>事务会把数据库从一种一致状态转换为另一种一致状态。</p>
<p>ACID特性：</p>
<p>原子性 automicity</p>
<p>一致性 consistency</p>
<p>隔离性 isolation（锁）</p>
<p>持久性 durability</p>
<p>原子性、一致性、持久性通过数据库的redo和undo来完成。</p>
<p>事务日志：redo日志文件和InnoDB存储引擎日志缓冲。在写数据前先写日志，即对于内存缓冲池中页的修改，先是写入重做日志文件，然后再写入磁盘。</p>
<p>undo日志：记录了事务的行为，存放在数据库内部的一个特殊段中，成为undo段，位于共享表空间内。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/13/view/" itemprop="url">
                  View 的工作原理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-13T17:16:58+08:00" content="2016-06-13">
              2016-06-13
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/源码分析/" itemprop="url" rel="index">
                    <span itemprop="name">源码分析</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="ViewRoot-amp-DocerView"><a href="#ViewRoot-amp-DocerView" class="headerlink" title="ViewRoot &amp; DocerView"></a>ViewRoot &amp; DocerView</h3><p>ViewRoot对应于 ViewRootImpl类，是连接WindowManager和DecorView的纽带，View的三大流程（measure layout draw）都是通过ViewRoot来完成的，在ActivityThread中，当Activit被创建完毕后，会将DecorView添加到Window中，创建ViewRootImpl,并将ViewRootImpl对象和DecorView建立联系</p>
<p>View的绘制是从ViewRoot的performTraversals方法开始的，进过measure layout draw，将View绘制出来。</p>
<p>measure 确定View的宽和高</p>
<p>layout 确定在父容器中的位置</p>
<p>draw负责将View绘制在屏幕上</p>
<p>performMeasure——&gt;measure——&gt;onMeasure(在该方法中完成对所有子元素的measure过程) getMeasureWidth getMeasureHeight</p>
<p>performLayout 同理 getTop getBottom getLeft getRight</p>
<p>performDraw</p>
<h3 id="MeasureSpec"><a href="#MeasureSpec" class="headerlink" title="MeasureSpec"></a>MeasureSpec</h3><p>View的测量规格</p>
<p>MeasureSpec在很大程度上决定了View的尺寸规格，在测量的过程中，系统会将View的LayoutParam根据父容器所施加的规则转换成对应的MeasureSpec,然后再根据这个MeasureSpec来测量View的宽和高</p>
<p>MeasureSpec 代表32位int值，高2位代表SpecMode 低30位代表SpecSize，</p>
<p>SpecMode </p>
<p>UNSPECIFIED 系统内部使用</p>
<p>EXACTLY match_parent 有具体宽和高的</p>
<p>AT_MOST wrap_content</p>
<p>DecorView：的MeasureSpec尺寸由窗口的尺寸和其自身的LayoutParams来共同决定</p>
<p>普通View：    的MeasureSpec，由父容器的MeasureSpec和其自身的LayoutParams共同确定</p>
<h3 id="View的工作流程"><a href="#View的工作流程" class="headerlink" title="View的工作流程"></a>View的工作流程</h3><p>measure</p>
<pre><code>protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    setMeasuredDimension(
    getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),
    getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec)
    );
}

public static int getDefaultSize(int size, int measureSpec) {
    int result = size;
    int specMode = MeasureSpec.getMode(measureSpec);
    int specSize = MeasureSpec.getSize(measureSpec);

    switch (specMode) {
    case MeasureSpec.UNSPECIFIED:
        result = size;
        break;
    case MeasureSpec.AT_MOST:
    case MeasureSpec.EXACTLY:
        result = specSize;
        break;
    }
    return result;
}
</code></pre><p>得出结论：直接继承View的自定义控件，需要重写onMeasure方法，如果该控件的宽或者高有wrap_content属性时，需要我们手动设定大小，否则就相当于match_parent</p>
<p>ViewGroup的measure过程：除了完成自身的measure过程，还会去遍历调用其各个子元素的measure方法，各个子元素再递归去执行这个过程。</p>
<p>ViewGroup是抽象类，没有onMeasure方法，提供了measureChildren方法：</p>
<pre><code>protected void measureChildren(int widthMeasureSpec, int heightMeasureSpec) {
    final int size = mChildrenCount;
    final View[] children = mChildren;
    for (int i = 0; i &lt; size; ++i) {
        final View child = children[i];
        if ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) {
            measureChild(child, widthMeasureSpec, heightMeasureSpec);
        }
    }
}
</code></pre><p>layout</p>
<p>draw</p>
<p>LinearLayout 的measure过程</p>
<pre><code>protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    if (mOrientation == VERTICAL) {
        measureVertical(widthMeasureSpec, heightMeasureSpec);
    } else {
        measureHorizontal(widthMeasureSpec, heightMeasureSpec);
    }
}
</code></pre><p>在Activity中获取View的宽和高</p>
<p>由于Activity的生命周期方法和View的measure过程不同步，通过getMeasureWidth/Heigth在onCreate onStrart onResume中均无法正确获得View 的宽高信息。解决该问题的方法：</p>
<ul>
<li>复写Activity的onWindowFocusChanged方法</li>
</ul>
<p>onWindowFocusChanged在窗口得到或者失去焦点的时候都会调用，如果频繁的进行onResume和onPause，那么onWindowFocusChanged会被频繁的调用。</p>
<pre><code>@Override
public void onWindowFocusChanged(boolean hasFocus) {
    super.onWindowFocusChanged(hasFocus);
    if(hasFocus) {
        int hight = iv_picture.getMeasuredHeight();
        int width = iv_picture.getMeasuredWidth();
    }
}
</code></pre><ul>
<li>view.post(runnable)</li>
</ul>
<p>通过post将runnable投递到消息队列的尾部，然后等待Looper调用此runnable的时候，View已经初始化好了。</p>
<pre><code>@Override
protected void onStart() {
    super.onStart();
    iv_picture.post(new Runnable() {
        @Override
        public void run() {
            int hight = iv_picture.getMeasuredHeight();
            int width = iv_picture.getMeasuredWidth();
        }
    });
}
</code></pre><ul>
<li>使用ViewTreeObserver</li>
</ul>
<p>当View树的状态发生改变或者View树内部的View可见性发生改变时，onGLoalLayout方法将会被回调。</p>
<pre><code>@Override
protected void onStart() {
    super.onStart();

    ViewTreeObserver observer = iv_picture.getViewTreeObserver();
    observer.addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {
        @Override
        public void onGlobalLayout() {
            iv_picture.getViewTreeObserver().removeOnGlobalLayoutListener(this);
            int hight = iv_picture.getMeasuredHeight();
            int width = iv_picture.getMeasuredWidth();
        }
    });

}
</code></pre><h2 id="Layout过程"><a href="#Layout过程" class="headerlink" title="Layout过程"></a>Layout过程</h2><p>ViewGroup用来确定子元素的位置，当ViewGroup的位置确定后，在它的onLayout方法中，会遍历所有子元素并调用其的layout方法，在子元素的layout方法中，onLayout又会被调用。</p>
<pre><code>public void layout(int l, int t, int r, int b) {
    if ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != 0) {
        onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec);
        mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;
    }

    int oldL = mLeft;
    int oldT = mTop;
    int oldB = mBottom;
    int oldR = mRight;

    boolean changed = isLayoutModeOptical(mParent) ?
            setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);

    if (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) {
        onLayout(changed, l, t, r, b);
        mPrivateFlags &amp;= ~PFLAG_LAYOUT_REQUIRED;

        ListenerInfo li = mListenerInfo;
        if (li != null &amp;&amp; li.mOnLayoutChangeListeners != null) {
            ArrayList&lt;OnLayoutChangeListener&gt; listenersCopy =
                    (ArrayList&lt;OnLayoutChangeListener&gt;)li.mOnLayoutChangeListeners.clone();
            int numListeners = listenersCopy.size();
            for (int i = 0; i &lt; numListeners; ++i) {
                listenersCopy.get(i).onLayoutChange(this, l, t, r, b, oldL, oldT, oldR, oldB);
            }
        }
    }

    mPrivateFlags &amp;= ~PFLAG_FORCE_LAYOUT;
    mPrivateFlags3 |= PFLAG3_IS_LAID_OUT;
}
</code></pre><p>layout的过程概述：首先通过setFrame方法来设定View的四个顶点的位置，接着调用onLayout方法，用于父容器确定子元素的位置。</p>
<p>LinearLayout的onLayout方法：</p>
<pre><code>@Override
protected void onLayout(boolean changed, int l, int t, int r, int b) {
    if (mOrientation == VERTICAL) {
        layoutVertical(l, t, r, b);
    } else {
        layoutHorizontal(l, t, r, b);
    }
}

void layoutVertical(int left, int top, int right, int bottom) {
    final int paddingLeft = mPaddingLeft;

    int childTop;
    int childLeft;

    // Where right end of child should go
    final int width = right - left;
    int childRight = width - mPaddingRight;

    // Space available for child
    int childSpace = width - paddingLeft - mPaddingRight;

    final int count = getVirtualChildCount();

    final int majorGravity = mGravity &amp; Gravity.VERTICAL_GRAVITY_MASK;
    final int minorGravity = mGravity &amp; Gravity.RELATIVE_HORIZONTAL_GRAVITY_MASK;

    switch (majorGravity) {
       case Gravity.BOTTOM:
           // mTotalLength contains the padding already
           childTop = mPaddingTop + bottom - top - mTotalLength;
           break;

           // mTotalLength contains the padding already
       case Gravity.CENTER_VERTICAL:
           childTop = mPaddingTop + (bottom - top - mTotalLength) / 2;
           break;

       case Gravity.TOP:
       default:
           childTop = mPaddingTop;
           break;
    }

    for (int i = 0; i &lt; count; i++) {
        final View child = getVirtualChildAt(i);
        if (child == null) {
            childTop += measureNullChild(i);
        } else if (child.getVisibility() != GONE) {
            final int childWidth = child.getMeasuredWidth();
            final int childHeight = child.getMeasuredHeight();

            final LinearLayout.LayoutParams lp =
                    (LinearLayout.LayoutParams) child.getLayoutParams();

            int gravity = lp.gravity;
            if (gravity &lt; 0) {
                gravity = minorGravity;
            }
            final int layoutDirection = getLayoutDirection();
            final int absoluteGravity = Gravity.getAbsoluteGravity(gravity, layoutDirection);
            switch (absoluteGravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) {
                case Gravity.CENTER_HORIZONTAL:
                    childLeft = paddingLeft + ((childSpace - childWidth) / 2)
                            + lp.leftMargin - lp.rightMargin;
                    break;

                case Gravity.RIGHT:
                    childLeft = childRight - childWidth - lp.rightMargin;
                    break;

                case Gravity.LEFT:
                default:
                    childLeft = paddingLeft + lp.leftMargin;
                    break;
            }

            if (hasDividerBeforeChildAt(i)) {
                childTop += mDividerHeight;
            }

            childTop += lp.topMargin;
            setChildFrame(child, childLeft, childTop + getLocationOffset(child),
                    childWidth, childHeight);
            childTop += childHeight + lp.bottomMargin + getNextLocationOffset(child);

            i += getChildrenSkipCount(child, i);
        }
    }
}
</code></pre><p>在上面的代码中，可以看到，layoutVertial方法会遍历所有子元素，并调用setChildFrame方法来为子元素指定对应的位置，其中childTop会逐渐增大，说明后面的子元素会被放在考下的位置。setChildFrame方法调用了子元素的layout方法。</p>
<p>那么：getMeasureWidth 和getMeasuerWidth的区别<br>一般情况下测量宽高和最终宽高是相等的，只是测量宽高形成与View的measure过程，最终宽高形成于View的layout过程。</p>
<h2 id="Draw过程"><a href="#Draw过程" class="headerlink" title="Draw过程"></a>Draw过程</h2><ul>
<li>background.draw(cavas) 绘制背景</li>
<li>onDraw 绘制自己</li>
<li>dispatchDraw 绘制children</li>
<li>onDrawScrollBars 绘制装饰</li>
</ul>
<p>以上全文是学习 <a href="http://item.jd.com/11760209.html" target="_blank" rel="external">《Android开发艺术探索》</a> 后的笔记</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/24/priorityqueue/" itemprop="url">
                  优先队列
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-24T16:16:43+08:00" content="2016-05-24">
              2016-05-24
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/数据结构与算法/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构与算法</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="数据结构与算法——优先队列-priority-queue"><a href="#数据结构与算法——优先队列-priority-queue" class="headerlink" title="数据结构与算法——优先队列(priority queue)"></a>数据结构与算法——优先队列(priority queue)</h3><p><img src="http://img1.imgtn.bdimg.com/it/u=2643490497,3065329328&amp;fm=21&amp;gp=0.jpg" alt="priority queue"></p>
<blockquote>
<p>优先队列的两种基本操作</p>
</blockquote>
<ul>
<li>insert(enqueue)</li>
<li>deleteMin(dequeue)</li>
</ul>
<blockquote>
<p>优先队列的实现——二叉堆(binary heap)</p>
</blockquote>
<ul>
<li>结构性</li>
<li>堆序性(heap-order property)：目的是快速找到最小的元素，所以讲最小元素放在根上，且所有的子树也都是堆结构，所以所有的节点都小于它的子节点。所以findMin的操作是常数时间</li>
</ul>
<p>完全二叉树： 除了底层都被完全填充的二叉树(底层从左到右依次填充，所以有可能没有完全填充)</p>
<p>一颗高为h的完全二叉树，有2^h到2^(h+1)个节点，即完全二叉树的高为O(logN)</p>
<p>完全二叉树用数组存储的规律：对于数组中任意位置i上的元素，它的左儿子位于2i处，右儿子位于(2i+1)处，父节点位于i/2(向下取整)处。遍历简单，运行快速。</p>
<p>优先队列完成insert和deleteMin两种操作的关键在于“上滤”和 “下滤”两种方法的实现</p>
<p>insert后，实现上滤操作</p>
<pre><code>public void insert(AnyType x) {

    //在插入之前先判断是否还有空间
    if(currentSize == array.length - 1) {

        enlargeArray(array.length * 2 + 1);

    }

    //上滤操作
    int hole = ++ currentSize;
    for(; hole &gt; 1 &amp;&amp; x.compareTo(array[hole/2]) &lt; 0 ; hole /=2) {
        array[hole] = array[hole / 2]; //没有使用swap(x,y)这种方式，这样交换的次数比较少
    }
    array[hole] = x;

}
</code></pre><p>deleteMin后实现下滤操作</p>
<pre><code>public AnyType deleteMin() {

    if(isEmpty()) {
//            throw new Exception();
    }

    AnyType minItem = findMin();
    array[1] = array[currentSize];
    currentSize--;
    percolateDown(1);

    return minItem;

}

private void percolateDown(int hole) {

    int child;
    //缓存要下虑的值
    AnyType tmp = array[hole];

    /**
     * 1. 找到hole的两个子节点中较小的一个child
     * 2. 比较child的值和tmp中的值大小
     * 3. child大于tmp：结束循环，tmp直接保存在hole中
     * 4. child小于tmp：将child的值保存到hole中，下一个hole = child
     * 5. 进行下一轮循环
     */

    for(; hole * 2 &lt; currentSize; hole = child) {

        //找到hole的左子节点
        child = hole * 2;
        //右子节点 &lt; 左子节点
        if(child &lt; currentSize &amp;&amp; array[child + 1].compareTo(array[child]) &lt; 0) {
            child ++;
        }

        //child 和 tmp比较大小
        if(array[child].compareTo(tmp) &lt; 0) {
            array[hole] = array[child];
        } else {
            break;
        }

    }

    array[hole] = tmp;

}
</code></pre><p><img src="http://www.zgxue.com/bloguploapic/20141116001225568.jpg" alt="priority queue"></p>
<p>堆结构的实现：</p>
<p>public class BinaryHeap<anytype extends="" comparable<?="" super="" anytype="">&gt; {</anytype></p>
<pre><code>private static final int DEFAULT_CAPACITY = 10;
private int currentSize;
private AnyType[] array;

public BinaryHeap() {
    this(DEFAULT_CAPACITY);
}

public BinaryHeap(int capacity) {
    currentSize = 0;
    array = (AnyType[]) new Comparable[capacity + 1];
}

public BinaryHeap(AnyType[] items) {

    currentSize = items.length;
    array = (AnyType[]) new Comparable[(currentSize + 2) * 11 / 10];

    int i = 1;
    for(AnyType item : items) {
        array[i++] = item;
    }

    buildHeap(); //建堆
}

/**
 * 建堆的过程：从完全二叉树的倒数第二层子树开始，对每个有子节点的节点执行下滤操作，
 * 确保每个节点小于自己的两个子节点即可
 */
private void buildHeap() {

    for(int i = currentSize / 2; i &gt; 0; i++) {
        percolateDown(i);
    }


}


public AnyType findMin() {

    if(isEmpty()) {
        return null;
    } else {
        return array[1];
    }

}

private boolean isEmpty() {

    return currentSize == 0;
}

private void enlargeArray(int size) {

    if(size &lt;= array.length) {
        return;
    } else {

        AnyType[] oldArray = array;
        array = (AnyType[]) new Comparable[size + 1];

        int i = 0;
        for(AnyType item : oldArray) {
            array[i++] = item;
        }
    }

}

/**
 * 插入时长：O(logN)
 * @param x
 */
public void insert(AnyType x) {

    //在插入之前先判断是否还有空间
    if(currentSize == array.length - 1) {

        enlargeArray(array.length * 2 + 1);

    }

    //上滤操作
    int hole = ++ currentSize;
    for(; hole &gt; 1 &amp;&amp; x.compareTo(array[hole/2]) &lt; 0 ; hole /=2) {
        array[hole] = array[hole / 2]; //没有使用swap(x,y)这种方式，这样交换的次数比较少
    }
    array[hole] = x;

}

public AnyType deleteMin() {

    if(isEmpty()) {
//            throw new Exception();
    }

    AnyType minItem = findMin();
    array[1] = array[currentSize];
    currentSize--;
    percolateDown(1);

    return minItem;


}

private void percolateDown(int hole) {

    int child;
    //缓存要下虑的值
    AnyType tmp = array[hole];

    /**
     * 1. 找到hole的两个子节点中较小的一个child
     * 2. 比较child的值和tmp中的值大小
     * 3. child大于tmp：结束循环，tmp直接保存在hole中
     * 4. child小于tmp：将child的值保存到hole中，下一个hole = child
     * 5. 进行下一轮循环
     */

    for(; hole * 2 &lt; currentSize; hole = child) {

        //找到hole的左子节点
        child = hole * 2;
        //右子节点 &lt; 左子节点
        if(child &lt; currentSize &amp;&amp; array[child + 1].compareTo(array[child]) &lt; 0) {
            child ++;
        }

        //child 和 tmp比较大小
        if(array[child].compareTo(tmp) &lt; 0) {
            array[hole] = array[child];
        } else {
            break;
        }


    }

    array[hole] = tmp;



}

}
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/24/vim/" itemprop="url">
                  vim基本操作
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-24T13:43:13+08:00" content="2016-05-24">
              2016-05-24
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/教程/" itemprop="url" rel="index">
                    <span itemprop="name">教程</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li>在某行按 A 添加文本，光标定位在该行的哪个字符不重要 a 在光标后插入文本</li>
<li>d w 从光标定位的字符删除到下一个单词的起始处 所以w键可以定位到下一个单词的起始处</li>
<li>d e 从光标定位的字符删除到该单词的末尾 e定位到本单词的末尾</li>
<li>d $ 从当前光标删除到行末 $定位到行尾</li>
<li>2 w 向后移动两个单词到单词的起始位置</li>
<li>3 e 向后移动三个单词，到单词的末尾</li>
<li>0 移动光标当行首</li>
<li>dd 删除当前行 xdd （x代表数字）删除x行</li>
<li>u撤销前一操作，U撤销整行的操作，Ctrl + r 恢复被撤销的操作</li>
<li>dd可以剪切 p粘贴</li>
<li>r 替换当前光标所在位置的字符</li>
<li>ce cw 改变一个单词并进入插入模式</li>
<li>Ctrl + g 显示当前行信息</li>
<li>G跳转到当前编辑文本的最后一行 gg跳转到当前文本的首行</li>
<li>行号 + G 跳转到该行</li>
<li>/ + 要搜索的内容 向后搜索</li>
<li>？ + 要搜索的内容 向前搜索</li>
<li>Ctrl + o 让光标回到之前的位置</li>
<li>Ctrl + i 与 Ctrl + o 相反</li>
<li>% 找到配对的{ [ (</li>
<li>:s/old/new/g 将光标当前行的第一个old字符串替换为new字符串</li>
<li>:%s/old/new/g  替换整个文本    :%s/old/new/gc  替换整个文本并对每一个替换进行提示</li>
<li>: + ! + 命令 + &lt;回车&gt; 在vim内执行shell命令 如: +  ! + ls</li>
<li>v 进入可视模式进行选取 选取好文本后，输入：可以看到vim底部出现：’&lt;,’&gt; 输入w TEST 可以将选取好的文件保存的TEST中</li>
<li>：r TEST 将TEST文件写入到当前文件中 : r ls 将ls命令显示的文件写入到当前文件中</li>
<li>o 在当前行下面插入一行 O 在当前行上方插入一行</li>
<li>R 连续替换多个字符</li>
<li>y 和 v结合进行复制 yw复制一个字符</li>
<li>:set ic 查找时忽略大小写 :set noic禁用大小写 只在一次查找中忽略大小写 /test\c test为要查找的单词</li>
<li>:set is 查找短语时显示部分匹配</li>
<li>:set hls 高亮显示</li>
<li>使用Ctrl + d 以及tab的自动补全功能</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/22/retrofit/" itemprop="url">
                  retrofit
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-22T14:43:19+08:00" content="2016-05-22">
              2016-05-22
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/源码分析/" itemprop="url" rel="index">
                    <span itemprop="name">源码分析</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="/images/retrofit2.png" alt="retrofit2"></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/22/JVM/" itemprop="url">
                  Java虚拟机概述（一）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-22T14:30:37+08:00" content="2016-05-22">
              2016-05-22
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Java虚拟机/" itemprop="url" rel="index">
                    <span itemprop="name">Java虚拟机</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="/images/JVM.png" alt="JVM"></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/avatar.jpg"
               alt="ADwangyang" />
          <p class="site-author-name" itemprop="name">ADwangyang</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/">
              <span class="site-state-item-count">18</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">8</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">12</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ADwangyang</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  



  
  
  

  

  

</body>
</html>
